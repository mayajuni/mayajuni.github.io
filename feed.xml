<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dongjun&#39;s Blog</title>
  
  <subtitle>Dongjun&#39;s Blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://mayajuni.github.io/"/>
  <updated>2020-05-28T23:36:25.135Z</updated>
  <id>https://mayajuni.github.io/</id>
  
  <author>
    <name>Dongjun Kwon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTO로 한해를 보내며.. (2019 회고)</title>
    <link href="https://mayajuni.github.io/2020/01/28/CTO%EB%A1%9C-%ED%95%9C%ED%95%B4%EB%A5%BC-%EB%B3%B4%EB%82%B4%EB%A9%B0-2019-%ED%9A%8C%EA%B3%A0/"/>
    <id>https://mayajuni.github.io/2020/01/28/CTO로-한해를-보내며-2019-회고/</id>
    <published>2020-01-28T05:19:00.000Z</published>
    <updated>2020-05-28T23:36:25.135Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tyle-h8b-01.png" alt="image"><br> 2020년 설이 지나서야 2019년 회고의 글을 씁니다. 목차를 만들어서 하나씩 회고를 하면서 써나갈까 합니다. 2019년은 정말 다사다난했습니다. 큰일들을 위주로 회고를 시작할까 합니다.</p><h1 id="CTO가-되다"><a href="#CTO가-되다" class="headerlink" title="CTO가 되다.."></a>CTO가 되다..</h1><p> ITAM GAMES는 2018년에 시니어 개발자로 입사하게 되었습니다. 개발자로서 만족하면서 개발 일을 프런트, 백앤드를 가리지 않고 개발을 했습니다. 2018년 말 전 CTO님께서 회사를 퇴사하면서 저희 대표님은 저에게 CTO 직을 제시하였고, 저는 거절했습니다. 하지만 결국은 2019년 1월.. CTO를 맡게 되었습니다. 총인원 약 60명 되는 회사의 CTO는 저에게 있어서 아직 부담으로 다가왔었습니다. 물론 개발팀만 50~60명은 아닙니다.<br> CTO를 하면서 많은 일이 있었고, <code>이불킥</code>을 할 정도로 부족했던 나의 모습, 하나하나의 결정에 따른 책임, 회사를 퇴사하겠다는 직원, 항상 무언가 새로운 것만 추구했던 사업부.. CTO는 정말 쉬운 직책이 아니고 편한 직책이 아님을 경험하고 있습니다. (현재도 CTO로 재직 중에 있습니다.)</p><h2 id="나의-뜻대로-되지-않는-모든-것"><a href="#나의-뜻대로-되지-않는-모든-것" class="headerlink" title="나의 뜻대로 되지 않는 모든 것."></a>나의 뜻대로 되지 않는 모든 것.</h2><p> 2019년 초에는 모든 것이 나의 뜻대로 되지 않았습니다. 팀원들은 나를 신뢰하지 않은 듯한 느낌을 받았고, 저의 진심을 알아주지 않은 팀원들에게 서운한 감정도 많이 들었습니다. 또한 개발일 정도 충분히 가능하리라 봤던 것들도 안되었습니다. 팀원들은 무언가 불만이 많았던 것처럼 보였으며, 나를 무시하는 느낌까지 받았었습니다. 사업부나 기획팀도 일정에 따른 압박을 주기 시작했고, 저는 CTO로서 첫 번째 고비가 다가왔었습니다.</p><h4 id="모든-잘못은-저로부터"><a href="#모든-잘못은-저로부터" class="headerlink" title="모든 잘못은 저로부터.."></a>모든 잘못은 저로부터..</h4><p> 2019년 초기에는 위에 써놓은 것처럼 모든 것이 마음대로 되지 않았고 그로 인한 쌈닭이 되어 가는 모습을 보게 되었습니다. 저를 바라보고 함께 일하고 싶어서 왔던 동료들인데 제가 변해 가는 모습을 몇 개월 후에나 알게 되었을 때 정말 고개를 들지 못할 정도로 미안함을 느끼게 되었습니다. 모든 것이 제가 미숙했던 거였습니다.</p><ol><li>왜 나는 동료들에게 다가가려 하지 않았을까?</li><li>먼저 신뢰를 얻으려고 하지 않을까?</li><li>일에 대한 욕심을 왜 이렇게까지 냈을까..</li><li>개발팀의 동료를 생각하지 않고 왜 회사의 입장만 고수하고 강요했을까?</li><li>모든 기준을 나로 두고 생각했을까..</li><li>팀원 각자가 특출난 부분이 있는데 왜 그걸 알아내지 못했으며, 알면서도 그에 맞게 활용을 못 했을까?</li><li>나 스스로 노력하지 않으면서, 나를 따라와 주고 믿어주며, 함께 할 거라 생각을 했을까?</li><li>동료의 말을 들으려고 하지 않을까?</li><li>한쪽 말만 듣고 판단하려고 했을까?</li><li>왜 한 달에 한 번씩 회고를 하지 못했을까..?</li><li>감정적으로 행동을 했으며, 말을 함부로 했을까..?</li></ol><p>위의 11가지 말고도 더 많은 잘못이 있었음을 너무 늦게 깨달았습니다. ‘그때 그렇게가 아니고 이렇게 했으면 조금 더 좋은 결과가 있었을 텐데..’라는 생각을 지금도 합니다.<br>그래도 늦게라도 회고하고 반성하며 아래와 같은 생각을 가지고 회사 생활을 하게 되었습니다.</p><ol><li>팀원들과 함께 하는 시간을 늘려보자. (함께 산책하기, 농담 따먹기 하기 등등)</li><li>내가 말하는 시간보다 듣는 시간을 늘려보자.</li><li>무언가 일을 진행할 때 욕심을 부리지 말자.</li><li>팀원 각자의 특출난 부분에 맞게 업무를 분배하고 나아가자.</li><li>감정적으로 행동하지 말고, 말을 함부로 하지 말자.</li><li>한쪽의 의견만 듣지 말고 양쪽의 의견을 듣고 판단하자.</li><li>팀원들을 신뢰하고 일을 맡기자.</li><li>업무에 대한 부족함이 있을 시에는 부족한 부분을 채워주도록 하는 게 나의 역활 중 하나라 생각하자.</li><li>새롭게 알게 된 지식은 공유하자.</li><li>한 달에 한 번쯤은 스스로 돌아보고 회고하자.</li><li>짧은 인생, 안 좋은 소리보다 좋은 소리를 하자.</li></ol><p>위의 11가지를 생각하면서 변화를 하게 되었고 지금 이 순간은 저희 개발팀은 서로 함께 늙어 가면서 평생 같이 보는 사이가 되었습니다. 더 크게 깨달은 것 중의 하나는 저는 정말 멘탈이 강한 줄 알았는데 맨탈이 강한 게 아니었다는 것을 느끼게 되는 2019년이었습니다.</p><blockquote><p>지금은 서로 술도 한잔하고 함께 진솔한 애기를 많이 합니다. 팀원들은 이렇게 얘기합니다. 2019년 초기만 해도 머 저런 미친X.. 쌍또라… 등으로 저를 얘기했는데 어떻게 이렇게 웃고 서로 힘이 되어 주고 도와주는 사이가 됐는지 신기해합니다. (자슥들아 너희와 내가 함께 노력한 거다 ㅋㅋㅋ) 그중 한 명은 진짜로 코드에 심각한 오류를 심어 놓고 퇴사할까 라는 생각도 했다고 합니다.</p></blockquote><h2 id="너무-많은-업무량"><a href="#너무-많은-업무량" class="headerlink" title="너무 많은 업무량.."></a>너무 많은 업무량..</h2><p> CTO가 되고 나서 정말 사업부는 너무 많은 업무와 짧고 짧은 기간을 주었습니다. 저는 이 부분을 어떻게 풀어 나가야 할지에 대해서 고민을 했습니다.</p><blockquote><p>저는 정말 야근이 싫었습니다. 그래서 팀원들에게 야근하게 만들고 싶지 않았습니다.</p></blockquote><h4 id="1-서버-관리는-하지-말자"><a href="#1-서버-관리는-하지-말자" class="headerlink" title="1. 서버 관리는 하지 말자."></a>1. 서버 관리는 하지 말자.</h4><p> 미친 듯한 업무량을 제한된 시간에 팀원들과 함께 풀어나가기에는 개발에만 집중하기에도 부족했습니다. 여기에 있어서 서버 관리까지 한다고 생각하니 답이 나오지 않았습니다. 그래서 선택을 아래와 같이 했습니다.</p><ol><li>Lambda를 사용해서 서버를 관리하지 말자.</li><li>S3, Route53, Cloudfront를 사용해서 SPA를 서비스하자</li><li>Codepipeline을 이용해서 자동 배포 시스템을 구축하자.</li><li>Mongodb를 사용하면서 직접 관리하지 말고 Mongodb Atlas를 사용하자.</li></ol><p>위와 같은 선택은 정말 신의 한 수였습니다. 선택에 따른 결과는 아래와 같았습니다.</p><ol><li>서버 관리가 더 이상 필요하지 않았습니다.</li><li>Mongodb의 모든 설정 및 관리가 필요하지 않았습니다.</li><li>자동 배포로 인해 배포에 대한 부담감이 적어졌습니다.</li><li>모니터링 툴이 필요하지 않았습니다. (Cloud Watch를 사용했으며, 더 필요한 부분은 log를 남겼습니다)<br>결론적으로 개발에 집중 할 수 있는 환경을 만들었습니다. 지금도 그때의 선택은 정말 잘했다고 생각합니다.</li></ol><h4 id="2-급하게-처리할-수밖에-없던-업무들"><a href="#2-급하게-처리할-수밖에-없던-업무들" class="headerlink" title="2. 급하게 처리할 수밖에 없던 업무들.."></a>2. 급하게 처리할 수밖에 없던 업무들..</h4><p> 짧은 일정은 충분히 잘 만들 수 있던 서비스를 일정에 치여서 아쉬운 상태로 완료된 경우가 너무 많았습니다. 대표님과도 해당 이슈에 대한 부분에 대해 많은 얘기를 했지만, 항상 결과는 회사가 나아가기 위해서는 어쩔 수 없이 그 기간 안에 서비스가 나와야 된다는 애기로 끝났습니다.<br> 지금 생각해보면 정말 어리석은 결정이었습니다. 제가 조금 더 강하게 의견을 말했으면 어땠을까 라는 생각을 많이 합니다.</p><p> 위와 같은 결정에 따른 결과는 아래와 같은 부정적으로 나타나기 시작했습니다.</p><ol><li>완성도의 하락.</li><li>그때 그 순간만을 위한 개발.</li><li>개발자의 의욕 상실.</li><li>기술의 부채.</li><li>엄청난 기회비용의 낭비.</li><li>효율적이지 못한 업무.</li></ol><p>위와 같은 상황은 개발팀뿐만 아니라 회사 전체에 악영향을 주었다고 생각합니다. 지금은 이와 같은 상황을 만들지 않기 위해서 노력하고 있습니다. (부채를 열심히 갚고 있고요..)</p><h2 id="효율적인-업무-방식"><a href="#효율적인-업무-방식" class="headerlink" title="효율적인 업무 방식"></a>효율적인 업무 방식</h2><p> CTO가 되면서 욕심을 부리고 싶었던 부분은 효율적인 업무 방식이었습니다. 그에 따라서 정말 다양한 툴을 사용했었습니다.</p><ol><li>트렐로 + 슬랙</li><li>테스크월드 + 슬랙</li><li>github(저장소마다 있는 project) + 슬랙</li><li>먼데이 + 슬랙</li><li>노션 + 텔레그램(현재)</li></ol><p>위의 5가지를 써보았고, 효율적인 업무를 위해서 애자일 방법론들을 짬뽕하고 조합해서 다양하게 적용을 해봤습니다. 하지만 결과적으로는 실패하게 되었습니다. 그에 따른 경험을 공유할까 합니다.</p><h3 id="1-모두가-함께-노력해야-된다"><a href="#1-모두가-함께-노력해야-된다" class="headerlink" title="1. 모두가 함께 노력해야 된다."></a>1. 모두가 함께 노력해야 된다.</h3><p> 모든 업무를 Task 화 하고 그에 맞게 스프린트를 단위로 개발을 하자라는 목표로 시작을 했습니다. 먼저 바로 모든 것을 바꾸기에는 무리가 있었다고 판단하였고 작은 거부터 시작하자는 목표로 진행했습니다. 하지만 쉽지 않았습니다. 누구에게는 이 방식이 편했고 누구에게는 이 방식이 불편했습니다.<br>업무수행 방식에 대한 약속 또한 지키지 못하는 경우가 자주 발생하였습니다. 업무수행 방식의 변화는 어느 순간부터 팀원들에게 스트레스가 되었고, 개발팀을 제외한 다른 팀, 대표님한테도 불필요한 일처럼 느끼게 만들어졌습니다. 또한 많은 업무량에 이와 같은 업무수행 방식의 변화는 더욱더 안 좋은 인식을 가져다주었습니다. 결론적으로 업무수행 방식의 변화는 회사 전체가 서로 도와줘야 된다는 것을 느끼게 되었습니다. 무엇보다도 대표님이 이해해주고 도와줘야 된다는 것을 절실하게 느꼈습니다. 그리고 엄청난 업무량과 짧은 기간에는 그냥 폭포수처럼 할 수밖에 없나? 정말 방법이 없을까? 라는 생각을 많이 하게 되었습니다. 이와 같은 경험은 2019년에는 아직 업무수행 방식을 변경하기에는 시기상조라는 결론을 내리게 되었고, 2020년에는 꼭 여유를 가지고 지금보다 나은 효율적인 업무수행 방식을 도입하겠다는 다짐을 했습니다.</p><h3 id="2-인식의-변화가-필요"><a href="#2-인식의-변화가-필요" class="headerlink" title="2. 인식의 변화가 필요"></a>2. 인식의 변화가 필요</h3><p> 효율적인 업무수행 방식은 회사에서 일하는 모두가 인식의 변화가 필요합니다. 그리고 이것을 적용하고 효율을 보기 위해서는 많은 시간과 노력이 필요하다는 것도 알아야 됩니다. 기존에 일했던 방식과 매우 다를 수도 있기 때문에 주변에서도 많이 도와줘야 되고 여유를 가지고 적용해야 된다는 것을 느꼈습니다.</p><h3 id="3-효율적인-업무수행-방식은-편하지-않다"><a href="#3-효율적인-업무수행-방식은-편하지-않다" class="headerlink" title="3. 효율적인 업무수행 방식은 편하지 않다."></a>3. 효율적인 업무수행 방식은 편하지 않다.</h3><p> 편하다는 것과 효율적이라는 말은 같지 않습니다. 효율적으로 업무를 하기 위해서는 불편함을 느낄 수밖에 없습니다. 가끔 효율적으로 업무 수행하는 게 편하게 일하는 거 아니에요? 라고 하지만 절대 아님을 알고 있어야 됩니다.</p><h3 id="4-업무수행-방식의-시스템화"><a href="#4-업무수행-방식의-시스템화" class="headerlink" title="4. 업무수행 방식의 시스템화"></a>4. 업무수행 방식의 시스템화</h3><p> 확고한 체계를 가지고 시스템화 해야 됩니다. 아마 처음부터 확실한 시스템화는 하기 힘듭니다. 계속 보안하고 발전해 나가서 하나의 시스템으로 자리 잡게 해야 된다고 생각을 합니다. 그 누군가 새로 오든 혹은 누군가 회사를 퇴사하든가 문제없어야 되니깐요..</p><h3 id="5-대표님의-도움"><a href="#5-대표님의-도움" class="headerlink" title="5. 대표님의 도움(?)"></a>5. 대표님의 도움(?)</h3><p> 실패의 가장 큰 요인은 대표님이 불편해했고 불필요하다고 느꼈다는 것입니다. 그 누구보다 앞장서서 도와주셨으면 반은 성공하지 않을까 생각도 합니다.</p><p>효율적인 업무수행 방식을 도입하기 위해서는 많은 어려움이 있음을 경험하고 알게 되었습니다. 하지만 절대 포기할 수 없기도 하고요. 효율적으로 업무를 하는 회사가 있으면 경험도 하고 싶습니다. 그리고 구글이나 아마존 등등에서는 어떻게 업무를 하고 있는지도 궁금하기도 하고요. 2020년에는 조금 더 효율적인 업무수행 방식에 대해서 경험도 하고 싶고 도입을 해야 한다는 다짐을 합니다.</p><h2 id="퇴사를-원하는-직원"><a href="#퇴사를-원하는-직원" class="headerlink" title="퇴사를 원하는 직원"></a>퇴사를 원하는 직원</h2><p> 직원들 모두가 한 회사에서 평생을 함께하지 않습니다. 특히나 스타트업에서는 있을 수 없는 일입니다. 우리 회사도 퇴사를 한 직원이 있었으며, 퇴사를 생각하다가 지금까지 함께 일하는 직원도 있습니다.<br> 제가 CTO가 아닌 개발자로 있었을 때는 크게 생각을 하지 않았습니다. 하지만 CTO가 되고 나서부터는 누군가가 퇴사한다고 할 때마다 가슴이 철렁합니다. 많지 않은 인원으로 개발팀을 꾸려가고 있는 상황에서 누군가 퇴사하면 모든 부분에 대해서 타격이 입기 때문입니다. 이와 같은 경험을 통해서 느낀 점은 아래와 같습니다.</p><ol><li><p>그 누구도 그만둘 수 있다. 준비하자.</p></li><li><p>퇴사를 막기 위해서 희망 고문 하지 말자.</p></li><li><p>퇴사라는 결정을 하기 전에 미리 방지할 수 있어야된다.</p></li><li><p>좋은 곳으로 이직을 하게 되면 진심으로 축하하자.</p></li><li><p>퇴사하는 직원이 있으면 다른 직원들도 동요하게 된다. 주의하자.</p></li><li><p>모든 계정 및 비밀번호를 쉽게 변경 할 수 있게 준비하자</p></li><li><p>항상 문서화를 해서 퇴사를 해도 영향력이 적게 처리하자.</p></li><li><p>누구보다 나 자신의 멘탈 관리를 하자.</p><p>함께 하다가 퇴사를 한다는 얘기를 들으면 정말 서운한 감정이 먼저 앞서게 됩니다. 그다음이 업무에 대해서 생각을 하게 되고요. 솔직히 처음에는 맨탈도 많이 흔들리기도 했습니다. 맨탈 관리도 중요합니다. 하지만 언제든 함께할 수 없다는 것을 알고 준비해야 되고 좋은 곳으로 이직을 했을 시에는 진심으로 축하해야 된다고 생각합니다. 나아가서 누군가 퇴사한다는 것은 회사 전체 분위기에도 좋지 않은 영향을 미칠 수 있습니다. 그렇기 때문에 꼭 주의를 해야 됩니다.</p><blockquote><p>그 무엇이 됐든 미리미리 준비하는 것이 최고의 방법이라 생각합니다.</p></blockquote></li></ol><h2 id="동기-부여"><a href="#동기-부여" class="headerlink" title="동기 부여"></a>동기 부여</h2><p> 동기부여는 정말 어렵습니다. 지금도 어렵고 앞으로도 어렵습니다. 솔직히 어떻게 해야 될지도 모르겠다고 표현하는 게 맞는 거 같습니다. CTO로서 개발팀의 동기부여를 하고 번아웃 되지 않게 잘 해야 되다는 얘기를 들었습니다. 동기부여 어떻게 해야 될까요?? 우선, 제가 직접 해본 방식은 아래와 같습니다.</p><ol><li>너는 혼자가 아니야 함께 하고 있어.</li></ol><ul><li>많은 얘기를 듣고 함께 하는 시간이 필요합니다. (가끔은 형으로써 동생으로서 조언도 하고요)</li><li>공감대 형성도 아주 중요하다고 생각합니다.</li></ul><ol start="2"><li>회사는 일만 하는 곳이 아니야.</li></ol><ul><li>하루에 회사에 있는 시간이 많습니다. 일만 하는 곳으로 생각이 들게 하는 게 아니라 가끔은 게임도 하고 떠들고 놀 수도 있게 만들었습니다.</li></ul><ol start="3"><li>흥미로운 기술 적용</li></ol><ul><li>정해진 기술만 가지고 개발을 한다면 본인 스스로가 정체된다는 느낌을 받을 수 있습니다. 팀원이 적용하고 싶은 기술이 있으면 언제든 오픈되어있고 적용도 할 수 있게 했습니다.</li></ul><ol start="4"><li>충분한 휴식을 주기</li></ol><ul><li>많은 업무량을 소화했으면 그것에 맞게 휴식도 주었습니다.</li></ul><ol start="5"><li>희망 고문은 하지 말자</li></ol><ul><li>처음에는 희망고문적인 말을 해봤습니다. 우리가 이렇게 하면 우리는 정말 잘될 거다 같은 느낌으로요. 하지만 순간순간은 동기부여가 될 수 있지만, 장기적으로 봤을 때는 좋지 않은 결과로 다가왔습니다.</li></ul><p>위와 같은 노력에도 불구하고 동기부여는 아직도 어렵습니다. 그리고 제가 열심히 노력한다고 해도 회사에서 그것에 맞게 따라주지 않으면 동기부여가 무산되기도 합니다. 누군가 동기부여에 대해서 강의를 하면 꼭 돈을 줘서라도 듣고 싶습니다.</p><h2 id="부정적인-분위기에-주의하자"><a href="#부정적인-분위기에-주의하자" class="headerlink" title="부정적인 분위기에 주의하자"></a>부정적인 분위기에 주의하자</h2><p> 재미있는 건 긍정적인 분위기보다는 부정적인 분위기가 쉽게 퍼집니다. 부정적인 분위기는 다들 아시겠지만 업무 효율부터 모든 것에 마이너스가 됩니다. 아래와 같은 상황을 주의해야 됩니다.</p><ol><li>누굴 탓하는 분위기</li><li>일하기 싫다는 분위기</li><li>퇴사하는 사람한테 나오는 무언가 퇴사해서 좋다는 분위기</li></ol><p>글 쓰는 이 순간에는 저 위의 3가지만 생각이 납니다. 부정적인 분위기는 막는다고 막히는 게 아니라고 생각은 합니다. 하지만 최대한 주의를 하고 미리 예방한다면 좋지 않을까 합니다.</p><h2 id="마지막으로"><a href="#마지막으로" class="headerlink" title="마지막으로.."></a>마지막으로..</h2><p> 너무 두서없이 주저리주저리 쓴 거 같습니다. 마지막으로 위의 글 말고도 생각나는 걸 그냥 막 나열해볼까 합니다.</p><ol><li>맨탈 관리 잘하자.</li><li>왜 CTO를 뽑을 때 경험이 있는 사람을 우대하는지 알겠다.</li><li>건강 관리하자.</li><li>사람은 누구나 특출나게 잘하는 곳이 있다. 그것에 맞게 업무 분배가 중요하다.</li><li>나 혼자 아무리 해보려고 해도 팀원이나 회사가 도와주지 않으면 아무것도 못 한다. 함께하자.</li><li>효율적인 업무수행 방식은 못하더라도 문서화는 꼭 하자.</li><li>욕심을 버리고 내려놓자.</li><li>누군가 나에 대해서 얘기를 하는 거에 예민하게 반응하지 말자.</li><li>말하기보다는 듣기를 조금 더 하자.</li><li>부족한 부분을 탓하기보다는 채워주기 위해서 노력하자.</li><li>말을 할 때 10번은 생각하고 말하자.</li><li>생각 할 수 있는 여유를 가지고 개발을 할 수 있는 환경을 만들자. (급하게 해서는 절대 안 된다)</li><li>진솔한 사람이 되자.</li></ol><p>아직도 많이 부족하기만 하다는 것을 글을 쓰면서 다시 한번 느끼게 됩니다. 2020년 제가 어떻게 될지는 모르겠지만 지금보다 조금 더 발전하고 나아가야겠습니다. 저와 함께 일한 동료들이 다시 또 함께 할 수 있게 그리고 개발자로서도 발전해 나가야겠다고 다짐을 합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tyle-h8b-01.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt; 2020년 설이 지나서야 2019년 회고의 글을 씁니다. 목차를 만들어서 하나씩 회고를 하면서 써나갈까 합니다. 2019년은 정말 다사다난했습니다. 큰일
      
    
    </summary>
    
    
      <category term="회고" scheme="https://mayajuni.github.io/categories/%ED%9A%8C%EA%B3%A0/"/>
    
    
      <category term="2019" scheme="https://mayajuni.github.io/tags/2019/"/>
    
      <category term="회고" scheme="https://mayajuni.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>Serverless를 선택한 이유(Lambda, Altas)</title>
    <link href="https://mayajuni.github.io/2020/01/17/Lambda%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0/"/>
    <id>https://mayajuni.github.io/2020/01/17/Lambda를-선택한-이유/</id>
    <published>2020-01-17T03:25:00.000Z</published>
    <updated>2020-05-28T23:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tyle-bfw-02.png" alt><br> CTO를 맡으면서 제가 선택하고 실무에 적용하면서 경험한 Serverless에 대해서 글을 남기려고 합니다.</p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless?"></a>Serverless?</h2><p> 여기에 와서 글을 읽으시는 분들은 Serverless가 무엇인지 충분히 알고 있을 거라고 생각합니다. 그래도 간단하게만 얘기한다면 진짜 Server가 없는 것은 아니고 Server를 신경 쓰지 않아도 서비스를 할 수 있게 하는 기술이라고 보면 됩니다.<br> 조금 더 있어 보이게 얘기한다면 <strong><em>애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없는 클라우드 컴퓨팅 모델을 가리킵니다.</em></strong><br> 여기에서 저는 실무에 적용하고 경험한 Lambda와 Mongodb Atlas 등 Serverless를 선택한 이유와 그에 대한 글을 남길까 합니다.</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p> 람다는 AWS에서 만든 <strong><em>서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있게 해주는 컴퓨팅 서비스</em></strong>입니다. 솔직히 말이 조금 어렵지만 단순하게 서버 관리가 필요 없이 함수를 실행해 주는 놈? 이라고 생각하는 게 편합니다.</p><p><strong>람다를 사용했을 시 장점은 무엇이 있을까?</strong></p><ol><li>개발에만 집중 할 수 있는 환경이 됩니다.</li><li>서버에 대해서 고민을 할 필요가 없습니다. (오토스캐일링부터 다양한 관점에서)</li><li>비용이 저렴합니다.</li><li>서버뿐만 아니라 AWS의 기능에 대한 트리거 및 스케줄로 등등으로 사용이 가능합니다. (예로 code pipeline에서 s3 배포를 완료 후 Cloud front 캐시 초기화할 때도 사용됩니다)</li></ol><p><strong>장점만 있으면 좋겠지만 단점도 존재합니다.</strong></p><ol><li>콜드 스타트 부분입니다. 최근에 동시성이라는 기능이 추가되어서 많이 좋아지긴 했습니다. 하지만 디비 커넥션과 같은 부분은 콜드 스타트 부분에서 초기화되기 때문에 생각을 해줘야 됩니다.</li><li>로그 보는 부분이 매우 불편합니다. (AWS의 CloudWatch를 통해서 볼 수 있지만 불편합니다)</li><li>동시 실행에 대한 제한이 있습니다.</li></ol><p><strong>단점을 극복 한 저의 경험은?</strong></p><ol><li>콜드 스타트<ul><li>해당 부분은 현재 15분마다 해당 function을 호출해 주는 방법이 가장 좋다는 생각은 듭니다. 하지만 MSA로 구현이 되어 있다면 수많은 function을 호출하는 게 비용적인 측면에서 문제가 있을 수 있습니다. 저는 Lambda의 사용을 꼭 MSA로 구현하지 않아도 된다고 생각하기 때문에 해당 부분은 어떻게 설계하냐에 따라 달라질 거라 생각합니다.</li></ul></li><li>로그 문제<ul><li>lambda를 호출하는 부분에 공통으로 로그를 남기는 부분을 만들어 놓았습니다. 물론 x-ray와 같은 서비스를 사용해도 좋겠지만 그거보다는 직접 호출이 되었을 시 그리고 오류가 났을 시 등등을 전부 에러 로그 처리해 놓고 확인하게 하였습니다. 다음에는 ELK를 이용하여 로그 분석 관련해서 작업을 진행할까 생각도 하고 있습니다.</li></ul></li><li>동시 실행에 대한 제한<ul><li>이 부분은 방법이 없습니다. 미리미리 AWS에 동시 실행에 대한 제한 부분을 풀어 놓으면 됩니다.</li></ul></li><li>제한된 모니터링 툴<ul><li>Lambda에 대한 모니터링 툴은 많이 부족하고 찾기 힘듭니다. 물론 CloudWatch가 있긴하지만 뭔가 부족함이 있다는 것을 느낄 수 있습니다. 아직 이 부분은 정도 CloudWatch를 확인하네요.</li></ul></li></ol><p><strong>Lambda를 직접 운영/개발을 하면서 알게 된 팁.</strong></p><ol><li>Lambda layer를 꼭 사용해야 합니다.<ul><li>layer 같은 경우는 외부 코드나 라이브러리, 모듈 등을 사전에 압축하여 하나의 큰 모듈처럼 사용 할 수 있게 해줍니다.</li><li>layer를 사용하면 deploy 부분에 대한 속도 부분이 극명하게 차이 날 정도로 빨라집니다.</li></ul></li><li>Serverless Framework 사용 추천<ul><li>이 부분을 팁으로 놓아야 하나 고민은 많이 되었습니다. 하지만 다른 프레임워크보다는 다양한 플러그인 지원, 그리고 방대한 커뮤니티 등등이 Lambda 혹은 Serverless를 사용하면서 큰 도움이 되었다고 생각합니다.</li></ul></li><li>Codepipeline 사용한 자동배포<ul><li>AWS를 사용해서 배포를 자동화하면 좋습니다. 보안에 민감할 수 있으니 해당 배포에 대한 권한을 개발자에게 주기보다는 AWS IAM을 이용해서 자동 배포 할시에만 주는걸 추천해 드립니다.</li></ul></li><li>MSA?? 굳이… 상황에 맞게 처리.<ul><li>Lambda를 사용하면 MSA를 해야 될 거 같은 느낌을 받을 수 있지만, 굳이 그렇게 할 필요가 없습니다. Monolithic과 비슷하게 1개의 endpoint에 1개의 function으로 해도 됩니다. 제가 추천하는 건 적당한 선에서 상황에 맞게 처리하는 것을 추천합니다.</li><li>MSA를 했을 때에는 DB 커젝션 수부터 로그 부분 그리고 function이 많아질 경우 그거에 대한 관리 등등을 고민해야 됩니다. 또한 콜드 스타트 때문에 매번 lambda 호출 시 드는 비용에 대해서도 고민할 필요가 있습니다.</li><li>Monolithic으로 했을 때에는 너무 방대해진 코드의 용량에 대해 고민을 할 필요가 있습니다. 또한 동시 실행의 제한도 미리미리 신청해서 늘려 놓아야 됩니다.</li></ul></li></ol><p>** Lambda를 선택한 이유**</p><p>위의 다양한 의견을 내긴 했지만 제가 Lambda를 선택한 가장 큰 이유는 서버 관리가 필요하지 않고 개발에 집중 할 수 있는 환경을 구성 할 수 있기 때문입니다. Lambda에서 나오는 단점은 충분히 커버도 가능할 거라 생각하고요. 비용 부분도 저렴합니다. 우선 프리티어와 관계없이 월 1백만 호출까지는 무료로 알고 있습니다. 호출된 횟수에 맞게 돈을 지불하기 때문에도 저렴하다고 말 할 수 있습니다. 트레픽이 많아지면 많이 비싸진다는 애기도 있긴 합니다. 이 부분도 말씀드리고 싶은것은 우선 Lambda가 아닌 다른 것을 사용해도 트레픽이 많아지면 가격이 비싸집니다. 물론 딱 물리적인 가격만 비교하면 Lambda가 비싸게 느껴질 수 있지만 트레픽 대응에 대한 서버 관리, 인력 고용 등등을 생각도 해야 됩니다.(대용량 트레픽에 따른 서버 관리하는 사람을 고용하는 것도 어렵고 급여도 많이 높을 거라 생각합니다) 이 모든 비용을 바라본다면 Lambda가 저렴하다고 생각합니다.</p><h2 id="Mongodb-Atlas"><a href="#Mongodb-Atlas" class="headerlink" title="Mongodb Atlas"></a>Mongodb Atlas</h2><p> Mongodb Atlas는 Mongodb management service(MMS)입니다. 말이 어렵게 느껴질 수 있지만 결국 serverless로 mongodb에 대한 모든 관리는 Atlas에서 해준다고 생각하면 편합니다. Lambda랑 비슷합니다. 한때는 Mlab이 가장 유명했지만 mongodb에서 인수를 하면서 서비스가 종료되었습니다.</p><p>** Mongodb Atals의 장점 **</p><ol><li>가장 좋은 건 Mongodb에 대한 관리가 필요 없습니다. Server부터 모든 기능 전부(리플리카셋, 샤딩 등등)</li><li>모니터링 툴을 따로 쓸 이유가 없습니다.</li><li>알람 또한 너무 잘되어 있어서 빠르게 확인 할 수 있습니다.</li><li>Performance Advisor라는 기능을 제공하여 쿼리 속도부터 index가 필요한 부분까지 체크해줍니다.</li><li>멀티 리전을 사용할 수 있습니다.</li><li>스토리지에 대한 Auto Scaling을 제공합니다.</li><li>백업에 대해서도 지원합니다. (실시간 백업도 가능, 4.2버전 이상은 아직 미지원)</li></ol><p>** 단점은? **</p><ol><li>비용이 저렴하진 않습니다.</li></ol><p>단점 부분은 솔직히 비용을 적긴 했지만 저는 합리적이라고 생각합니다. 단점을 찾기가 쉽지 않네요..</p><p>** Mongodb Atals를 사용하면서 알게 된 팁 **</p><ol><li>같은 리전, 같은 클라우드<ul><li>당연한 소리이지만 같은 리전 그리고 같은 클라우드 서비스로 만드는 것을 추천합니다. (이유는 굳이 설명 안 하겠습니다.)</li></ul></li><li>Database Access 권한<ul><li>Database Access 권한인 경우는 모든 클러스트 공통으로 적용이 됩니다. 저희 같은 경우 개발 클러스트와 실 클러스트를 운영하는데 Database Access 권한을 주면 둘 다 동일하게 적용되었습니다. (다른 방법이 있는데 제가 모르는 거 일 수도 있습니다) 그렇기 때문에 해당 부분을 확인하는 게 좋습니다.</li></ul></li><li>Network Access 권한<ul><li>Network Access 같은 경우 보통 0.0.0.0/0으로 세팅 하는 경우가 있는데 보안상 추천하지 않습니다. 꼭 화이트 리스트로 하는 것을 추천합니다.</li></ul></li><li>vpc peering<ul><li>VPC peering을 한다고 해서 체감상 속도가 빨라지진 않습니다. 다만 이걸 하는 것을 추천하는 이유는 보안상의 이유가 크다고 볼 수 있습니다.</li></ul></li><li>Performance Advisor 기능<ul><li>Performance Advisor 기능을 적극적으로 활용해야 됩니다. 정말 신기할 정도로 잘 추천해주고 그것에 맞게 처리하면 성능 개선을 확실히 볼 수 있습니다. 다만 초기에 데이터가 없을 시에는 확인이 되지 않을 수 있습니다.</li></ul></li><li>스케일 업<ul><li>mongodb 스케일 업 시에는 간단하게 버튼만으로 추가 할 수 있습니다. 다만 스케일업 하는 동안은 서비스가 되지 않기 때문에 충분한 공지를 통해서 하시는걸 추천해 드립니다.</li></ul></li></ol><p>** Mongodb Atlas를 선택한 이유**</p><p> 똑같은 소리를 반복하는 거일 수 있지만 서버 관리, 몽고디비의 다양한 기능, 설정 등등을 직접 관리할 필요가 없고 개발에 집중 할 수 있는 환경을 조성 할 수 있기 때문입니다. 초기에는 Atlas가 아닌 직접 mongodb를 운영도 해보았습니다. EC2 3대와 글로벌 서비스를 위한 버지니아에 read 전용 EC2 2대까지 총 5대를 세팅하고 운영을 하면서 다양한 버그, 에러 그리고 모니터링 툴의 필요성, 알람의 필요성, 백업 계획 등등을 느끼고 있었지만, 개발을 할 수 있는 인력 및 여건이 되지 않아 Atlas로 옮기는 결정을 하고 작업을 했습니다. 옮기고 나서 만족도는 1,000,000%입니다. 다만 단점이라고 하면 비용에 있습니다. 하지만 위의 부가적인 작업 및  Mongodb에 문제가 있을 시 등등의 기회비용 인력 비용 모든 것을 다 합한다고 하면 합리적이라고 생각합니다.</p><h3 id="Serverless-왜-선택했냐"><a href="#Serverless-왜-선택했냐" class="headerlink" title="Serverless 왜 선택했냐?"></a>Serverless 왜 선택했냐?</h3><p> Serverless를 선택한 이유는 아래와 같습니다.</p><ol><li>개발에 집중하는 환경<ul><li>많은 스타트업이 그렇겠지만 개발자는 뽑기 힘들고 많이 있지 않습니다. (어디 있나요..?) 많지 않은 인력으로 서비스 개발만 해도 시간이 부족합니다. 그렇기 때문에 개발에 집중할 수 있는 환경을 조성하기 위한 하나의 선택지라 생각합니다.</li></ul></li><li>Serverless에서 제공하는 기능들<ul><li>Lambda, Atlas에서 제공하는 기능들은 정말 꿀과 같습니다. (특히 Atlas) 이런 기능들은 직접 만들고 유지하고 운영하기에는 저희는 인력도 부족하고 시간도 부족합니다.</li></ul></li><li>합리적인 비용<ul><li>물리적인 하드웨어를 따지고 보면 비싸게 느껴질 수 있지만 모든 기회비용까지 생각하면 오히려 저렴하다고 생각합니다. (개발자 몸값만 생각해도…)</li></ul></li><li>전문 지식<ul><li>Serverless를 이용하지 않고 직접 운영을 한다면 해당 기술에 대한 전문지식이 필요합니다. 다양한 버그, 상황에 맞는 설정 등 경험을 해보지 못하는 경우가 많고 아무리 많이 안다고 해도 전문적으로 해당 기술에 대한 Serverless 하는 회사에 보다는 많이 부족함도 사실입니다.</li></ul></li></ol><h3 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며."></a>마무리하며.</h3><p> 다양한 서비리스 중 2가지만 애기하기 했지만 다른 좋은 서버리스도 많습니다. 상황에 맞게 그리고 비즈니스에 맞게 잘 활용한다면 아주 큰 도움이 될 수 있다고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/tyle-bfw-02.png&quot; alt&gt;&lt;br&gt; CTO를 맡으면서 제가 선택하고 실무에 적용하면서 경험한 Serverless에 대해서 글을 남기려고 합니다.&lt;/p&gt;
&lt;h2 id=&quot;Serverless&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="server" scheme="https://mayajuni.github.io/categories/server/"/>
    
    
      <category term="aws" scheme="https://mayajuni.github.io/tags/aws/"/>
    
      <category term="lambda" scheme="https://mayajuni.github.io/tags/lambda/"/>
    
      <category term="serverless" scheme="https://mayajuni.github.io/tags/serverless/"/>
    
      <category term="server" scheme="https://mayajuni.github.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>EosJS API 사용</title>
    <link href="https://mayajuni.github.io/2018/08/01/EosJS-API-%EC%82%AC%EC%9A%A9-1/"/>
    <id>https://mayajuni.github.io/2018/08/01/EosJS-API-사용-1/</id>
    <published>2018-08-01T01:32:00.000Z</published>
    <updated>2020-05-28T23:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EosJS-API-사용"><a href="#EosJS-API-사용" class="headerlink" title="EosJS API 사용"></a>EosJS API 사용</h1><p>안녕하세요. 권동준 입니다.<br> 이전에 EOSJS 시작하기에서 간단하게 EOSJS를 사용하는 방법을 해봤습니다. 이번에는 EosJs에서 제공하는 api 중에 자주 쓰는 api를 소개하고 테스트 할 수 있게 진행을 하려고 합니다. </p><blockquote><p>api 목록을 보기를 원하시면 <a href="https://github.com/EOSIO/eosjs-api/blob/master/docs/api.md#eos--object" target="_blank" rel="noopener">여기</a>를 확인해 보시면 됩니다. </p></blockquote><h4 id="시작하기에-앞서-준비하기"><a href="#시작하기에-앞서-준비하기" class="headerlink" title="시작하기에 앞서 준비하기"></a>시작하기에 앞서 준비하기</h4><p>모든 코드를 직접 사용 해볼 수 있게 할 예정입니다. 그렇게 하기 위해서는 준비가 필요합니다. </p><p>준비 사항은 아래와 같습니다.</p><ol><li>nodeJs</li><li>eosJs</li></ol><p>위의 2개를 설치하고 javascript 파일 가장 위에 아래와 같이 넣어주세요.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Eos = <span class="built_in">require</span>(<span class="string">'eosjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    expireInSeconds: <span class="number">60</span>,</span><br><span class="line">    broadcast: <span class="literal">true</span>,</span><br><span class="line">    debug: <span class="literal">false</span>,</span><br><span class="line">    sign: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// mainNet bp endpoint</span></span><br><span class="line">    httpEndpoint: <span class="string">'https://api.eosnewyork.io'</span>,</span><br><span class="line">    <span class="comment">// mainNet chainId</span></span><br><span class="line">    chainId: <span class="string">'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eos = Eos(config);</span><br></pre></td></tr></table></figure><p>이렇게 넣고 나서 아래의 api 예제를 직접 코딩하고 nodeJs로 javascript를 실행하면 값이 나옵니다.</p><blockquote><p>Bp Endpoint마다 응답속도 혹은 신뢰도가 각각 다르게 때문에 본인에 가장 맞는 bp를 사용하기를 권장합니다.</p></blockquote><h4 id="getBlock-blockNumOrId"><a href="#getBlock-blockNumOrId" class="headerlink" title="getBlock(blockNumOrId)"></a>getBlock(blockNumOrId)</h4><p>해당 블록의 정보를 가지고 올 수 있습니다.</p><p>params:</p><table><thead><tr><th>param</th><th>설명</th></tr></thead><tbody><tr><td>block_num_or_id</td><td>블록의 아이디나 number</td></tr></tbody></table><p>Code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">eos.getBlock(<span class="number">1</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result)).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">eos.getBlock(<span class="number">1</span>, (error, result) =&gt; <span class="built_in">console</span>.log(error, result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters object</span></span><br><span class="line">eos.getBlock(&#123;<span class="attr">block_num_or_id</span>: <span class="number">1</span>&#125;).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>결과 값: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123; timestamp: '2018-06-08T08:08:08.500',</span><br><span class="line">  producer: '',</span><br><span class="line">  confirmed: 1,</span><br><span class="line">  previous:</span><br><span class="line">   '0000000000000000000000000000000000000000000000000000000000000000',</span><br><span class="line">  transaction_mroot:</span><br><span class="line">   '0000000000000000000000000000000000000000000000000000000000000000',</span><br><span class="line">  action_mroot:</span><br><span class="line">   'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',</span><br><span class="line">  schedule_version: 0,</span><br><span class="line">  new_producers: null,</span><br><span class="line">  header_extensions: [],</span><br><span class="line">  producer_signature:</span><br><span class="line">   'SIG_K1_111111111111111111111111111111111111111111111111111111111111111116uk5ne',</span><br><span class="line">  transactions: [],</span><br><span class="line">  block_extensions: [],</span><br><span class="line">  id:</span><br><span class="line">   '00000001405147477ab2f5f51cda427b638191c66d2c59aa392d5c2c98076cb0',</span><br><span class="line">  block_num: 1,</span><br><span class="line">  ref_block_prefix: 4126519930 &#125;</span><br></pre></td></tr></table></figure><p>해당 블록에서 어떠한 일을 했는지 보기 위해서는 transactions를 보면 됩니다. </p><p>transactions를 보기 위해 아래와 같이 한번 같이 해보시죠.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; <span class="attr">status</span>: <span class="string">'executed'</span>,</span><br><span class="line">    cpu_usage_us: <span class="number">1170</span>,</span><br><span class="line">    net_usage_words: <span class="number">40</span>,</span><br><span class="line">    trx:</span><br><span class="line">     &#123; <span class="attr">id</span>:</span><br><span class="line">        <span class="string">'8a29bfa66850b7d4a2b0b62173a24c5dfe4dbd7b39c211df6309d02a85374960'</span>,</span><br><span class="line">       signatures: [<span class="built_in">Array</span>],</span><br><span class="line">       compression: <span class="string">'none'</span>,</span><br><span class="line">       packed_context_free_data: <span class="string">''</span>,</span><br><span class="line">       context_free_data: [],</span><br><span class="line">       packed_trx:</span><br><span class="line">        <span class="string">'9051595bad38f016a289000000000100a6823403ea3055000000572d3ccdcd0110e0a53cab294d7600000000a8ed3232dd0110e0a53cab294d76a0986af64b96bc65010000000000000004454f5300000000bb01496e74726f647563696e67204954414d204e6574776f726b2c20616e20454f532d426173656420444150502050726f6a656374206f6e20426c6f636b636861696e2047616d696e6720506c6174666f726d20666f722061205472616e73706172656e742047616d696e672045636f73797374656d2e202d2d576562736974653a2068747470733a2f2f6974616d2e67616d65732f656e202d2d54656c656772616d3a2068747470733a2f2f742e6d652f6974616d6e6574776f726b00'</span>,</span><br><span class="line">       transaction: [<span class="built_in">Object</span>] &#125; &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>위와 같은 값으로 주며 저기에서도 transaction를 보면 actions가 있으며 그걸 보면 이 블록에서 어떤일들을 했는지 더욱 깊게 볼 수 있습니다.</p><h3 id="getAccount-accountName"><a href="#getAccount-accountName" class="headerlink" title="getAccount(accountName)"></a>getAccount(accountName)</h3><p>Eos계정의 정보를 가지고 올때 사용합니다.</p><p>Params:</p><table><thead><tr><th>Param</th><th>설명</th></tr></thead><tbody><tr><td>account_name</td><td>eos 계정의 이름</td></tr></tbody></table><p>Code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">eos.getAccount(<span class="string">'itamnetwork1'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">eos.getAccount(<span class="string">'itamnetwork1'</span>, (error, result) =&gt; <span class="built_in">console</span>.log(error, result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters object</span></span><br><span class="line">eos.getAccount(&#123;<span class="attr">account_name</span>: <span class="string">'itamnetwork1'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure><p>결과 값</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123; account_name: 'itamnetwork1',</span><br><span class="line">  head_block_num: 8516805,</span><br><span class="line">  head_block_time: '2018-07-30T07:34:52.500',</span><br><span class="line">  privileged: false,</span><br><span class="line">  last_code_update: '1970-01-01T00:00:00.000',</span><br><span class="line">  created: '2018-07-09T02:24:58.500',</span><br><span class="line">  core_liquid_balance: '12.6131 EOS',</span><br><span class="line">  ram_quota: 14976,</span><br><span class="line">  net_weight: 201000,</span><br><span class="line">  cpu_weight: 10401000,</span><br><span class="line">  net_limit: &#123; used: 1679786, available: 11108657, max: 12788443 &#125;,</span><br><span class="line">  cpu_limit: &#123; used: 7950353, available: 6356380, max: 14306733 &#125;,</span><br><span class="line">  ram_usage: 10934,</span><br><span class="line">  permissions:</span><br><span class="line">   [ &#123; perm_name: 'active', parent: 'owner', required_auth: [Object] &#125;,</span><br><span class="line">     &#123; perm_name: 'owner', parent: '', required_auth: [Object] &#125; ],</span><br><span class="line">  total_resources:</span><br><span class="line">   &#123; owner: 'itamnetwork1',</span><br><span class="line">     net_weight: '20.1000 EOS',</span><br><span class="line">     cpu_weight: '1040.1000 EOS',</span><br><span class="line">     ram_bytes: 14976 &#125;,</span><br><span class="line">  self_delegated_bandwidth:</span><br><span class="line">   &#123; from: 'itamnetwork1',</span><br><span class="line">     to: 'itamnetwork1',</span><br><span class="line">     net_weight: '0.1000 EOS',</span><br><span class="line">     cpu_weight: '0.1000 EOS' &#125;,</span><br><span class="line">  refund_request: null,</span><br><span class="line">  voter_info:</span><br><span class="line">   &#123; owner: 'itamnetwork1',</span><br><span class="line">     proxy: '',</span><br><span class="line">     producers: [],</span><br><span class="line">     staked: 4000,</span><br><span class="line">     last_vote_weight: '0.00000000000000000',</span><br><span class="line">     proxied_vote_weight: '0.00000000000000000',</span><br><span class="line">     is_proxy: 0 &#125; &#125;</span><br></pre></td></tr></table></figure><p>위의 결과값중에 다 중요하지만 몇개만 설명을 하려 합니다.</p><ol><li><p>account_name<br>누구나 다 알다 싶이 eos account name 입니다.</p></li><li><p>ram_quota</p><p>내가 보유한 RAM 입니다. 단위는 byte입니다.</p></li><li><p>net_limit</p><p>해당 계정이 가지고 있는 총 net, 사용 가능한 net, 사용한 net을 나타냅니다. 단위는 byte입니다.</p></li><li><p>cpu_limit</p><p>해당 계정이 가지고 있는 총 cpu, 사용 가능한 cpu, 사용한 cpu을 나타냅니다. 단위는 us 입니다.</p></li><li><p>ram_usage</p><p>해당 계정이 사용한 RAM 입니다 단위는 byte입니다.</p></li><li><p>total_resources<br>나에게 할당된 리소스의 eos를 보여줍니다. (누군가가 나에게 delegated한 것도 포함됩니다.)</p></li><li><p>self_delegated_bandwidth<br>내가 내 자신에게 delegated한 정보 입니다.</p></li><li><p>voter_info</p><p>투표에 대한 정보입니다. 여기에서 눈여겨 봐야될 부분은 staked입니다. 이부분은 현재 내가 staked 한 부분인데요. 좀더 자세히 설명한다면 내가 스스로 내 자신에게 delegated한 부분과 누군가에서 delegated한 부분을 포함한 값입니다.</p></li></ol><h3 id="getKeyAccounts-publicKey"><a href="#getKeyAccounts-publicKey" class="headerlink" title="getKeyAccounts(publicKey)"></a>getKeyAccounts(publicKey)</h3><p>public key에 해당하는 account들을 가지고 옵니다.</p><p>Params:</p><table><thead><tr><th>Param</th><th>설명</th></tr></thead><tbody><tr><td>public_key</td><td>EOS의 public key</td></tr></tbody></table><p>Code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">eos.getKeyAccounts(<span class="string">'EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">eos.getKeyAccounts(<span class="string">'EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5'</span>,</span><br><span class="line">    (error, result) =&gt; <span class="built_in">console</span>.log(error, result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters object</span></span><br><span class="line">eos.getKeyAccounts(&#123;<span class="attr">public_key</span>: <span class="string">'EOS6S6C5ExCM7VHGdmG5h6VREVJEC33bpMJtLucwhyByPmzB58KW5'</span>&#125;)</span><br><span class="line">    .then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>결과값:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; account_names: [ 'itamnetwork1' ] &#125;</span><br></pre></td></tr></table></figure><p>EOS의 public key 한개로 여러 account를 만들수 있습니다. 그렇게 때문에 account_name의 값이 string으로 이루어진 array 입니다.</p><h3 id="getCurrencyBalance-code-account-symbol"><a href="#getCurrencyBalance-code-account-symbol" class="headerlink" title="getCurrencyBalance(code, account, symbol)"></a>getCurrencyBalance(code, account, symbol)</h3><p>code의 symbol에 해당하는 Token을 가지고 옵니다. </p><p>Params:</p><table><thead><tr><th>Param</th><th>설명</th></tr></thead><tbody><tr><td>code</td><td>컨트렉트 명 혹은 해당 컨트렉트가 있는 account명을 말합니다.<br>ex) eosio.token, therealkarma 등등</td></tr><tr><td>account</td><td>조회할 EOS의 계정명 입니다.</td></tr><tr><td>symbol</td><td>Token의 symbol 입니다. 이부분은 필수값이 아닌 옵션 값입니다.</td></tr></tbody></table><p>Code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">eos.getCurrencyBalance(<span class="string">'eosio.token'</span>, <span class="string">'itamnetwork1'</span>, <span class="string">'EOS'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">eos.getCurrencyBalance(<span class="string">'eosio.token'</span>, <span class="string">'itamnetwork1'</span>, <span class="string">'EOS'</span>,</span><br><span class="line">    (error, result) =&gt; <span class="built_in">console</span>.log(error, result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters object</span></span><br><span class="line">eos.getCurrencyBalance(&#123;<span class="attr">account</span>: <span class="string">'itamnetwork1'</span>, <span class="attr">code</span>: <span class="string">'eosio.token'</span>, <span class="attr">symbol</span>: <span class="string">'EOS'</span>&#125;)</span><br><span class="line">    .then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>결과값:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ '<span class="number">12.6131</span> EOS' ]</span><br></pre></td></tr></table></figure><p>결과 값을 보면 string형식의 array가 나옵니다. 이유는 해당 컨트렉트안에 여러 symbol을 가진 token들이 있을수 있기 때문입니다. EOS 테스트넷인 정글넷을 보면 symbol을 제외하고 eosio.token을 조회하면 2개의 token들을 볼수 있습니다.</p><h3 id="getCurrencyStats-code-symbol"><a href="#getCurrencyStats-code-symbol" class="headerlink" title="getCurrencyStats(code, symbol)"></a>getCurrencyStats(code, symbol)</h3><p>symbol에 해당하는  Token의 정보를 가지고 옵니다.</p><p>Params:</p><table><thead><tr><th>Param</th><th>설명</th></tr></thead><tbody><tr><td>code</td><td>컨트렉트 명 혹은 해당 컨트렉트가 있는 account명을 말합니다.<br>ex) eosio.token, therealkarma 등등</td></tr><tr><td>symbol</td><td>Token의 symbol 입니다.</td></tr></tbody></table><p>Code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">eos.getCurrencyStats(<span class="string">'eosio.token'</span>, <span class="string">'EOS'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">eos.getCurrencyStats(<span class="string">'eosio.token'</span>, <span class="string">'EOS'</span>,</span><br><span class="line">    (error, result) =&gt; <span class="built_in">console</span>.log(error, result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters object</span></span><br><span class="line">eos.getCurrencyStats(&#123;<span class="attr">code</span>: <span class="string">'eosio.token'</span>, <span class="attr">symbol</span>: <span class="string">'EOS'</span>&#125;)</span><br><span class="line">    .then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>결과값:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; EOS:</span><br><span class="line">   &#123; supply: '1006148640.3388 EOS',</span><br><span class="line">     max_supply: '10000000000.0000 EOS',</span><br><span class="line">     issuer: 'eosio' &#125; &#125;</span><br></pre></td></tr></table></figure><p>결과값에 대한 설명은 아래와 같습니다.</p><ol><li><p>supply<br>현재 공급된 토큰의 갯수 입니다.</p></li><li><p>max_supply</p><p>총 토큰의 갯수 입니다.</p></li><li><p>issuer<br>발행자 입니다.</p></li></ol><h2 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h2><p>자주 쓰는 api들중 5개를 소개하는 시간을 가지게 되었습니다. 아직 더 많은 api들이 있고 다음 블로그에 이어서 많이 쓰는 api들에 대해서 연재할 계획입니다. 감사합니다.</p><blockquote><p>해당 예제는 <a href="https://github.com/ITAMNETWORK/eosjs-api-example" target="_blank" rel="noopener">github</a>에서 확인 하실 수 있습니다.</p></blockquote><p>해당 게시글은 저의 블로그 혹은 itamnetwork 블로그에서 동일하게 확인 하실수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EosJS-API-사용&quot;&gt;&lt;a href=&quot;#EosJS-API-사용&quot; class=&quot;headerlink&quot; title=&quot;EosJS API 사용&quot;&gt;&lt;/a&gt;EosJS API 사용&lt;/h1&gt;&lt;p&gt;안녕하세요. 권동준 입니다.&lt;br&gt; 이전에 EOSJS 
      
    
    </summary>
    
    
      <category term="eos" scheme="https://mayajuni.github.io/categories/eos/"/>
    
      <category term="eosjs" scheme="https://mayajuni.github.io/categories/eos/eosjs/"/>
    
    
      <category term="eosjs" scheme="https://mayajuni.github.io/tags/eosjs/"/>
    
  </entry>
  
  <entry>
    <title>eosJs 시작하기</title>
    <link href="https://mayajuni.github.io/2018/07/16/eosJs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"/>
    <id>https://mayajuni.github.io/2018/07/16/eosJs-시작하기/</id>
    <published>2018-07-16T05:19:00.000Z</published>
    <updated>2020-05-28T23:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EOSJS-시작하기"><a href="#EOSJS-시작하기" class="headerlink" title="EOSJS 시작하기"></a>EOSJS 시작하기</h2><h4 id="EOSJS란"><a href="#EOSJS란" class="headerlink" title="EOSJS란?"></a>EOSJS란?</h4><p>EOS 블록체인을 javascript로 좀더 편하게 컨트롤 할 수 있게 만들어 놓은 라이브러리라고 생각하면 편하다. 살짝만 깊게 들어가면 EOS에서 제공하는(nodeos) HTTP API를 이용하게 편하게 해 놓은 거라고 말 할 수 있다. (이더리움에는 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>, 네오에는 <a href="https://github.com/CityOfZion/neon-js" target="_blank" rel="noopener">neon-js</a>) </p><blockquote><p>EOSJS도 EOS에서 제공하는 HTTP API를 사용하기 때문에 BP들을 잘 선택해야된다.(응답속도, 제공여부 등등)</p></blockquote><h4 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h4><p>설치 방법으로는 2가지가 있다.</p><ol><li><p>NPM을 통해서 간단하게 설치 할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install eosjs</span><br></pre></td></tr></table></figure></li><li><p>CNS를 이용하기</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/eosjs@15.0.3/lib/eos.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha512-QX0dPq5pyX33coEuy5x1UqKHFDeveQYMp7Sz+qOUwRL9mol4QDvViU+QAjd+k6P7QjPjrDCoyhK1kz2GDxCP9A=="</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="EOS-Connect"><a href="#EOS-Connect" class="headerlink" title="EOS Connect"></a>EOS Connect</h4><ol><li><p>EOSJS를 이용한 EOS Connect</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Eos = <span class="built_in">require</span>(<span class="string">'eosjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 하면 localhost Testnet에 접근한다.</span></span><br><span class="line"><span class="keyword">const</span> eos = Eos();</span><br></pre></td></tr></table></figure><p>localhost에 EOS가 구동 되어있지 않는다면 위의 코드를 실행하면 아래와 같은 에러가 난다. (당연히 connect하는 EOS의 httpEndpoint가 틀려도 아래와 같은 에러가 나온다.)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123; FetchError: request to http://127.0.0.1:8888/v1/chain/get_info failed, reason: connect ECONNREFUSED 127.0.0.1:8888</span><br><span class="line">    at ClientRequest.&lt;anonymous&gt; (/Users/mayajuni/Projects/eos-scan/node_modules/node-fetch/index.js:133:11)</span><br><span class="line">    at ClientRequest.emit (events.js:182:13)</span><br><span class="line">    at Socket.socketErrorListener (_http_client.js:382:9)</span><br><span class="line">    at Socket.emit (events.js:182:13)</span><br><span class="line">    at emitErrorNT (internal/streams/destroy.js:82:8)</span><br><span class="line">    at emitErrorAndCloseNT (internal/streams/destroy.js:50:3)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:63:19)</span><br><span class="line">  name: 'FetchError',</span><br><span class="line">  message:</span><br><span class="line">   'request to http://127.0.0.1:8888/v1/chain/get_info failed, reason: connect ECONNREFUSED 127.0.0.1:8888',</span><br><span class="line">  type: 'system',</span><br><span class="line">  errno: 'ECONNREFUSED',</span><br><span class="line">  code: 'ECONNREFUSED' &#125;</span><br></pre></td></tr></table></figure></li><li><p>Mainnet connect 하기</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Eos = <span class="built_in">require</span>(<span class="string">'eosjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eos = Eos(&#123;<span class="attr">httpEndpoint</span>: <span class="string">'mainnet httpEndpoint'</span>&#125;);</span><br></pre></td></tr></table></figure><p>아마 위와 같이 connect를 시도 한다면 아래와 같은 에러 메시지가 나온다.<br> <img src="/images/error.png" alt="connect-error"></p><p>에러가 나더라도 getInfo는 가능하네 이걸 통해서 chainId를 확인해서 넣자. </p><blockquote><p>Mainnet인 경우는 aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906 이것이 공통으로 쓰는 chainId이기 때문에 넣으면 된다.</p></blockquote></li></ol><p>위와 같은 방법으로 connect를 하면 아래와 같이 최초 1회 get_info api를 호출한다. (처음에 이것도 모르고 매번 커넥트를 줬더니 모바일에서 데이터 사용량이 아주 높게 나온적이 있다.)</p><p><img src="/images/net.png" alt="network-image"></p><blockquote><p>메인넷 주소는 <a href="https://api.eosnewyork.io" target="_blank" rel="noopener">https://api.eosnewyork.io</a> 여기에서 확인 해 볼 수 있다. BP들마다 제공하는 정보의 양, 응답속도 등등이 다르기 때문에 확인을 해서 본인에게 가장 잘 맞는 BP를 찾는 것이 좋다.(혹은 본인이 직접 full node를 받아서 연결하는 방법도 있다.)</p></blockquote><h6 id="Connect-Config"><a href="#Connect-Config" class="headerlink" title="Connect Config"></a>Connect Config</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Eos = <span class="built_in">require</span>(<span class="string">'eosjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  chainId: <span class="literal">null</span>, <span class="comment">// 32 byte (64 char) hex string</span></span><br><span class="line">  keyProvider: [<span class="string">'PrivateKeys...'</span>], <span class="comment">// WIF string or array of keys..</span></span><br><span class="line">  httpEndpoint: <span class="string">'http://127.0.0.1:8888'</span>,</span><br><span class="line">  expireInSeconds: <span class="number">60</span>,</span><br><span class="line">  broadcast: <span class="literal">true</span>,</span><br><span class="line">  verbose: <span class="literal">false</span>, <span class="comment">// API activity</span></span><br><span class="line">  sign: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eos = Eos(config);</span><br></pre></td></tr></table></figure><p>이부분의 자세한 내용은 github에 있으니 여기에서 확인하면 된다.(<a href="https://github.com/EOSIO/eosjs#configuration" target="_blank" rel="noopener">github-configuration</a>)</p><h4 id="getInfo-api"><a href="#getInfo-api" class="headerlink" title="getInfo - api"></a>getInfo - api</h4><p>EOS의 기본 네트워크 정보를 가지고 올 수 있다. 코드는 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eos = Eos().getInfo(<span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>재미 있는 것은 다른 api들은 전부 Promise를 기본으로 하는데 getInfo만 callback방식이다.</p></blockquote><p>리턴된 값은 아래와 같다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    server_version: '36a043c5',</span><br><span class="line">    chain_id:</span><br><span class="line">        'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',</span><br><span class="line">    head_block_num: 5469047,</span><br><span class="line">    last_irreversible_block_num: 5468711,</span><br><span class="line">    last_irreversible_block_id:</span><br><span class="line">        '00537227a657d1f4fd74de877e9ad1a3839540ece45eedeaf177b20e51b2da1b',</span><br><span class="line">    head_block_id:</span><br><span class="line">        '005373770504c59e992214b3056c7bdabb07c53c5a9c4785909b90fe595a119f',</span><br><span class="line">    head_block_time: '2018-07-12T08:58:05.500',</span><br><span class="line">    head_block_producer: 'helloeoscnbp',</span><br><span class="line">    virtual_block_cpu_limit: 200000000,</span><br><span class="line">    virtual_block_net_limit: 1048576000,</span><br><span class="line">    block_cpu_limit: 199900,</span><br><span class="line">    block_net_limit: 1048576</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서(EOS Connect) 애기 했던 chainId를 모를 경우 getInfo를 통해서 chainId를 얻어서 쓸 수 있다.</p><p>이번 글에서는 설치, connect, getInfo만 첫 걸음이라는 생각으로 가볍게 알아보았다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;EOSJS-시작하기&quot;&gt;&lt;a href=&quot;#EOSJS-시작하기&quot; class=&quot;headerlink&quot; title=&quot;EOSJS 시작하기&quot;&gt;&lt;/a&gt;EOSJS 시작하기&lt;/h2&gt;&lt;h4 id=&quot;EOSJS란&quot;&gt;&lt;a href=&quot;#EOSJS란&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="eos" scheme="https://mayajuni.github.io/categories/eos/"/>
    
      <category term="eosjs" scheme="https://mayajuni.github.io/categories/eos/eosjs/"/>
    
    
      <category term="eosjs" scheme="https://mayajuni.github.io/tags/eosjs/"/>
    
      <category term="eos" scheme="https://mayajuni.github.io/tags/eos/"/>
    
      <category term="block chain" scheme="https://mayajuni.github.io/tags/block-chain/"/>
    
  </entry>
  
  <entry>
    <title>RethinkDB 소개</title>
    <link href="https://mayajuni.github.io/2017/03/27/RethinkDB-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"/>
    <id>https://mayajuni.github.io/2017/03/27/RethinkDB-시작하기/</id>
    <published>2017-03-27T04:18:00.000Z</published>
    <updated>2020-05-28T23:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i1.wp.com/developer.ibm.com/clouddataservices/wp-content/uploads/sites/47/2017/07/rethinkdb.png" alt></p><h1 id="RethinkDB란"><a href="#RethinkDB란" class="headerlink" title="RethinkDB란?"></a>RethinkDB란?</h1><p>Real-Time에 최적화된 오픈소스 데이터베이스라고한다. 그리고 확장 가능한 JSON 데이터 베이스이며, 전통적인 데이터베이스 아키텍처를 바꾸어 변경 사항을 폴링하는 대신 업데이트 된 쿼리 결과를 실시간, 지속적으로 push 할 수 있다고 한다.<br>특징을 설명하자면 아래와 같을꺼 같다.</p><ol><li>실시간에 최적화 되어 있다.</li><li>JSON 기반의 데이터베이스이다.</li><li>업데이트가 발생 되었을 시 지속적/실시간으로 push를 해준다.</li><li>확장이 쉬운 분산 데이터베이스</li><li>실시간 웹 애플리케이션 구죽을 위한 <code>오픈소스</code> 데이터 베이스</li><li>웹UI 관리 콘솔을 제공한다.(서버 성능 확인, 쿼리테스트 데이터 테이블과 샤드 등등을 관리하는 도구이다.)</li></ol><h2 id="RethinkDb와-실시간-동기화-서비스의-차이점은-무엇을까"><a href="#RethinkDb와-실시간-동기화-서비스의-차이점은-무엇을까" class="headerlink" title="RethinkDb와 실시간 동기화 서비스의 차이점은 무엇을까?"></a>RethinkDb와 실시간 동기화 서비스의 차이점은 무엇을까?</h2><p>RethinkDb는 Firebase, pubNub, pusher와 같은 실시간 API와 근본적으로 다른 3가지가 있다. </p><ol><li>실시간 동기화 API는 클라우드 서비스이고 RethinkDB는 오픈소스 프로젝트이다. </li><li>실시간 동기화 API는 문서 동기화에만 국한되며, RethinkDB는 범용 데이터베이스 시스템이다. 테이블 조인, 하위쿼리, 지형공간 쿼리 등등을 포함한 쿼리를 실행 할 수 있다. </li><li>실시간 동기화 API는 브라우저에서 직접 액세스하도록 설계되어 있다. 이러면 기본 앱을 쉽게 실행 할 수 있지만 앱이 확장되면 유연성이 제한된다. RethinkDB는 기존 데이터베이스와 같이 응용 프로그램 서버에서 엑세스 할 수 있도록 설계되어 있다. 쉽게 말해 많은 유연성을 가지고 있다.</li></ol><h2 id="RethinkDB와-MongoDB의-차이점은-무엇일까"><a href="#RethinkDB와-MongoDB의-차이점은-무엇일까" class="headerlink" title="RethinkDB와 MongoDB의 차이점은 무엇일까?"></a>RethinkDB와 MongoDB의 차이점은 무엇일까?</h2><p>RethinkDB를 살펴 보면 Mongodb의 oplog가 생각이 든다. 물론 그거 말고도 비슷한 점이 많긴 하다. 하지만 기본적으로 다른 아키텍처를 기반으로 되어 있다. 개발자는 변경상항을 폴링하는 대신 실시간으로 업데이트 된 쿼리 결과를 계속 푸쉬하도록 RethinkDB에서 할 수 있다. 예로 들어 쿼리를 본다면 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.table(<span class="string">'users'</span>).get(<span class="string">'coffeemug'</span>).changes().run()</span><br></pre></td></tr></table></figure><p> 위에서 언급했지만 몽고디비의 oplog와 비교 될 수 있지만 oplog보다는 훨씬 노은 수준의 추상화를 제공한다.  RethinkDB의 피드는 쿼리 계산 엔진과 완벽하게 통합되므로 원시 복제 데이터뿐만 아니라 쿼리 결과의 변경 내용을 구독 할 수 있다. 이 아키텍처는 확장 가능한 실시간 응용 프로그램을 구축하는 데 필요한 시간과 노력을 크게 줄일 수 있다. </p><p>이외에도 MongoDB에 비해 여러가지 장점을 제공한다.</p><ul><li>테이블 조인, 하위 쿼리 및 대규모 병렬 분산 계산을 지원하는 고급 쿼리 언어다.</li><li>우아하고 강력한 연산 및 모니터링 API로 쿼리 언어와 통합되며 RethinkDB를보다 쉽게 확장 할 수 있다.</li><li>몇 번의 클릭만으로 샤드하고 복제 할 수있는 간단하고 아름다운 관리 UI 및 온라인 문서 및 쿼리 언어 제안을 제공한다.</li></ul><h2 id="시스템-요구-사항"><a href="#시스템-요구-사항" class="headerlink" title="시스템 요구 사항"></a>시스템 요구 사항</h2><p>RethinkDB 서버는 C++로 작성되었으며, 32비트 및 64비트 리눅스 시스템과 OS X 10.7이상에서 실행 할 수 있다.<br>최소 2기가 이상의 램을 권장하지만 업격한 하드웨어 요구 사항은 없다.(다른 블로그를 보니 램이 부족해서 몽고디비로 이전했다는 사람도 있긴했다.) </p><h2 id="라이센스는-무엇을까"><a href="#라이센스는-무엇을까" class="headerlink" title="라이센스는 무엇을까?"></a>라이센스는 무엇을까?</h2><p>RethinkDB 서버 및 클라이언트 드라이버는 <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener">Apache License 버전 2.0</a> 에 따라 사용이 허가됩니다 .</p><p>다음에는 간단한 설치부터 쿼리하는거까지 진행을 해보도록 하겠다. </p><p>참고사항</p><ol><li><a href="https://www.rethinkdb.com/faq/" target="_blank" rel="noopener">Rethink FAQ</a></li><li><a href="https://www.rethinkdb.com" target="_blank" rel="noopener">RethinkDB</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i1.wp.com/developer.ibm.com/clouddataservices/wp-content/uploads/sites/47/2017/07/rethinkdb.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;Rethi
      
    
    </summary>
    
    
      <category term="NoSql" scheme="https://mayajuni.github.io/categories/NoSql/"/>
    
      <category term="rethinkDB" scheme="https://mayajuni.github.io/categories/NoSql/rethinkDB/"/>
    
    
      <category term="rethinkDb" scheme="https://mayajuni.github.io/tags/rethinkDb/"/>
    
      <category term="NoSql" scheme="https://mayajuni.github.io/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>2016년 회고</title>
    <link href="https://mayajuni.github.io/2016/12/30/2016%EB%85%84-%ED%9A%8C%EA%B3%A0/"/>
    <id>https://mayajuni.github.io/2016/12/30/2016년-회고/</id>
    <published>2016-12-30T02:41:00.000Z</published>
    <updated>2020-05-28T23:36:25.135Z</updated>
    
    <content type="html"><![CDATA[<p>블로그를 운영 아닌 운영을 하면서 올해부터는 새롭게 회고를 해볼까 한다.<br>막상 회고를 한다고 하니 어떻게 글을 시작해야될지 머리속이 정리가 안된다. 또한 좋지 못하는 기억력을 다시한번 실감하게 되기도 하다.<br>시작을 어떻게 할까 고민을 하다가 카테고리를 나누어 써볼까 한다. </p><h2 id="여행"><a href="#여행" class="headerlink" title="여행"></a>여행</h2><h5 id="1-일본-오키나와"><a href="#1-일본-오키나와" class="headerlink" title="1. 일본(오키나와)"></a>1. 일본(오키나와)</h5><p> 1월에 전에 다녔던 회사(컴팔)에서 처음으로 해외 워크샵(이라고 부르지만 그냥 놀러, 술마시러)을 갔다왔다. 오키나와는 일본의 휴양도시고 아주 좋다는 애기를 많이 들어 되게 기대했다. 하지만 정말 실망적이였다. 비싼 가격, 같이간 사람들, 아름답지 않은 날씨 등등이 나에게 있어서는 아주 매력적이지 않았다. 그 돈이면 차라리 동남아를 가고 말지 라는 생각도 많이 들었다. 음식도 비싸기만 했지 별로…. 내가 이렇게 실망한 가장 큰 이유는 여행 스타일때문인거 같기도 하다. 회사에서 간거라 그런지 계속 차타고 이동 내리고 구경 저녁에 술… 역시 나는 배낭을 매고 이리저리 내 발로 걸어 다니면서 다니는 여행이 나에게 맞는거 같다. 아니면 아에 휴양이거나, 같이 간 사람들도 회사 사람들이다 보니 더욱 별로였던거 같다.(이 회사는 사내정치가 심한 회사라 직원들끼리 파가 나누어져있었다) 위안으로 삼은건 내돈 주고 온게 아니고 회사돈으로 와서 다행이다(?)이정도…</p><h5 id="2-인도-말레시아-잠시"><a href="#2-인도-말레시아-잠시" class="headerlink" title="2. 인도(+ 말레시아 잠시)"></a>2. 인도(+ 말레시아 잠시)</h5><p> 2014년도에 만난 인도 친구에게 결혼하면 꼭 결혼식에 참석하겠다라는 약속을 지키기 위해 떠난 여행이다. 다시 한번 인도에 대해 느끼게 되는 여행이기도 하다. 인도는 너무너무 힘들다..하하…. 내 여행인생 처음으로 비행기도 놓쳐보고(이때 진짜 인도가 싫었다. 그놈의 퍼스트서비스가 먼지 어떻게든 돈을 더 받아 먹을려고…에흉) 잠도 많이 못자기도 했다. 하지만 정말 좋은 점들도 있었다. 우선 정말 가족같은 우리 누나와 형님을 오랫만에 만난점.. 그리고 인도 친구의 결혼식(힌두결혼식)을 경험해 본것. 말레이시아에서 회사 직원과 함께 구경하고 밥먹었던 점은 정말 소중한 추억이고 기억이다. 아 특히 힌두 결혼식은 정말 특별하고 힘들었다. 이게 짧은거라고 하지만 나에게는 정말 하하… 결혼식 전날 신랑쪽(우리는 신부쪽이다)에서 마련한 공간에서 같이 춤추고 밥먹고 즐기는 것도 너무 재미 있었지만.. 결혼식 당일 새벽 4시에 일어나서 기도로 시작하고 결혼식장까지 가서 기도로 끝나는 모습은 정말… 하하… 종교가 대단하다는 생각도 많이 했다. 특히 인도 정통의상을 선물해 주고 그걸 입고 참석한 일, 외국인이라서 특히 2년전 약속을 지키기위해 온 우리를 좋게 생각해줘서 그런지 정말 이리저리 불려 많이 다녔다.. 5분도 못쉬고 정말 이리저리..(나의 사촌오빠의 엄마의 할아버지 등등) 그때 생각하면 참 힘들었지만 너무 즐거웠다.(하지만 힌두 결혼식은 2번 참석하기 힘들꺼 같다..하하) 마지막 돌아오는 하루는 말레이시아에 들렸다. 거기에서는 말레이시아 회사 직원이 차로 우리를 관광도 시켜줬다. 너무너무 고맙고 좋았던 기억이다. 거기서 잘때 호스텔에서 잤는데 특별했다 옥상에 올라가는 바가 있었는데 바로 쌍둥이 빌딩도 보이고 음악도 너무 좋고, 거기다 우리는 간단하게 맥주 마시는데 역시 배낭여행객이 많아서 그런데 너무 자연스럽게 외국인(우리도 외국인이긴하지만 하하)들과 함께 조인되어서 짧은 영어로 이리저리 애기하는게 너무 재미 있었다.</p><h5 id="3-베트남"><a href="#3-베트남" class="headerlink" title="3. 베트남"></a>3. 베트남</h5><p>회사를 그만두기로 하고 시간이 비어 떠난 베트남 여행이다. 하노이, 다낭, 호이안, 사파까지 비자기간인 2주를 거의 꽉 채웠다. 처음에는 혼자 먼저 떠나서 하노이에서 머물다가 와이프랑 와이프친구 만나고 와이프가 먼저 귀국하면 그다음에는 친동생같은 동생이 와서 같이 여행하는 좀 특이한 여행일정이였다. 하노이 생각하면 내가 지냈던 호스텔이 아직도 생각난다. 하룻밤에 6불인데 조식도 주고 밤에는 맥주도 무제한으로 줬었다..(남는게있어???) 특히 맥주 무제한 시간에는 이런 저런 사람들과 함께 애기하고 놀고 게임하는게 아주아주 재미있었다. 이때 영국남자 미국남자 미국커플 한국인들이랑 친해져서 같이 밥도 먹고.. 게임도 옆에 하노이 놀러온 중국인들과도 함께 했는데 너무너무 즐거웠다. 역시 우린 위아더 월드!!<br>와이프와서 같이간 다낭, 호이안 여기도는 하노이와 또 다른 매력을 지닌 곳이다. 여기에서 인생 조개요리를 먹었다. 로컬식당인데 영어를 못해서 서로 몸짓으로 음식 시키고 대화 했던거 생각하면 너무 재미있었다. 또 바로 옆 테이블 로컬 사람들이랑 같이 조인되서 영어를 못해 몸짓으로 서로 대화하고 맥주를 짝으로 마신 기억은 진짜 아우 ㅎㅎㅎ 너무 특별하다. 호이안은 너무 아름다운 도시였다. 하지만 여기서 진행했던 호핑투어는 진짜 아주 안좋은 기억이었다. 다행히 호텔에 컴플레인을 했더니 죄송하다고 하며, 돈을 깍아주고 공항까지 가는 택시를 지원해줬다. 나는 이런걸 원하는게 아니라서 거절을 막 했더니 이걸 안받으면 자신들이 혼난다고 하여 어쩔수 없이 받았다. 이 호텔은 정말 좋았다.. 다만 호핑투어가 안좋았을뿐…<br>다시 하노이 와서 와이프가 떠나고 동생이 왔다. 베트남에서 가장 좋았던 도시 <code>사파</code>로 떠났다. 하노이는 너무나 더웠는데 사파는 아주 시원했다. 그리고 산에 있어서 그런지 뷰가 아주 그냥… 음식도 너무 맛나고.. 진짜 천국(?) 여기에서도 나의 오지랍(?)으로 현지인 베트남 사람과 식당에서 함께 음식을 먹고 술도 한잔하면서 놀았다..하하….<br>바디랭기쥐는 영어도 필요 없게 한다… 영어 따윈 훗! 베트남은 사랑이다!!!</p><h5 id="4-체코"><a href="#4-체코" class="headerlink" title="4. 체코"></a>4. 체코</h5><p>어머니 환갑으로 떠나게 된 여행이다. 이 여행에서는 와이프에게 너무 고맙다. 시어머니랑 가는것도 쉽지 않은데 시어머니의 친구분(70대의 언니분이다. 이모라 부른다.)까지 함께 했으니 얼마나 힘들었을까… 모스크바를 들렸다가 체코 프라하를 갔다.<br>비행기는 러시아 항공을 이용했는데 만족스러웠다. 짐도 잃어버리지 않고.. 대망의 첫 모스크바.. 나는 정말 붉은성의 야경을 보고 싶었는데 못본게 가장 아쉽다. 하지만 모스크바(러시아)는 2번가진 않을꺼 같다. 물가도 비싸다능… 체코는 너무나 좋았다 특히 맥주는 아주 그냥.. 하루를 맥주로 시작하고 맥주로 끝냈다. 도시들도 너무나 아름답고 물가도 너무 싸다.. 만약 디지털 노마드를 한다고 하면 체코에서 살고 싶은 생각이다.. 아 첫 에어비앤비도 너무 저렴하고 좋았다. </p><h5 id="5-종합"><a href="#5-종합" class="headerlink" title="5. 종합"></a>5. 종합</h5><p>올해만 4번이나 여행을 갔다 왔지만 항상 또 가고 싶다.. 그리고 귀국하면 느낌은 꼭 갔다오지 않은 듯한 느낌이다. 동내 근처 놀러갔다온 느낌?? 그리고 항상 영어를 잘하고 싶다라고 생각해도 작심 3일… 2017년에는 꼭 영어 공부를 잘 해야겠다. 앞으로 2017년에 이미 잡혀 있는 10월(보라카이)여행을 말고는 자제를 해야겠다.. 돈도 모아서 집을 사야지.. 아시아나 마일리지가 동남아 왕복권이 있어서 내년에 한번 더 갈 가능성은 있긴하다..하하..</p><h2 id="가족"><a href="#가족" class="headerlink" title="가족"></a>가족</h2><p>기억에 나는건 역시나 우리 할아버지께서 돌아가신거다. 할아버지를 생각하면 말이 없으시지만 우리를 챙겨주시는 모습, 할머니가 잔소리 할때마다 은근슬쩍 피하는 모습.. 그리고 뇌졸증으로 쓰러지시고나서 회복후에는 할머니와 함께 손잡고 다니는 모습.. 할머니도 걱정되면서 어머니도 걱정 되었다. 하지만 걱정과 다르게 이겨내시는 모습에 안심이 된다. </p><blockquote><p>매년 경험하는 죽음.. 무언가 나에게 먼 느낌이면서도 아주 가까운 곳에 있는거 같다.. 여기서 다시 한번 생각한다. 나의 삶의 목표에 대해.. 그리고 중요한게 무엇인지 다시 한번 되세김 해본다.</p></blockquote><h2 id="회사"><a href="#회사" class="headerlink" title="회사"></a>회사</h2><h5 id="컴팔"><a href="#컴팔" class="headerlink" title="컴팔"></a>컴팔</h5><p>2년 넘게 함께한 그리고 아주 많은 일들이 있어던 회사(컴팔)에서 이직을 했다. 컴팔에서는 너무 편했다. 할일도 많지 않았고 내가 하고싶은데로 하면 되었기 때문이다. 하지만 나에게 있어서 너무 나태하게 하는 곳이기도 했다. 내가 짠 소스가 정확히 맞는 소스인지도 모르겠고, 누군가와 함게 개발을 하고 싶었다. 코드 리뷰도 하고 싶었고 개발적인 토론도 하고 싶었다. 컴팔은 나에게 아주 큰 공부도 되고 배움도 되는 곳이였지만 슬슬 도전을 해야 된다고 생각이 되는 시기였다. </p><h5 id="트레포트"><a href="#트레포트" class="headerlink" title="트레포트"></a>트레포트</h5><p>스카웃(면접제의)가 와서 면접을 보고 입사를 했다. 트레포트에서는 나를 포함한 우리 팀은 6명이였다. 신규 프로젝트를 진행했는데 내가 공부를 하고 있었던 angular2로 진행하였다. 여기서 문제는 나를 제외하고 전부 angular2를 몰랐다.. 한달간 리딩을 하고 공부를 진행하면서 프로젝트를 진행하였는데. 너무나도 고맙게 팀원들이 아주 잘 따라와 주었고 내가 만족할 정도로 포퍼먼스도 내주었다.(우리 팀원은 4년차 1명 2년차 1명 남어지는 신입이다..) rxjs와 data flow 기반의 코딩은 역시나 어려웠다. 나조차도 확실히 알지 못하는 상황에서 누군가를 가르친다는건 참 모순적이기도 했다. 그래도 팀원들이 아주 잘 따라와주었지만 아쉽게도 회사 사정상 첫번째 프로젝트는 중단하게 되었다. 이어서 한 두번째 프로젝트 기간은 길지 않았고 빠르게 진행하게 되었다. 그래서 우리는 이미 만들어진 컴포넌트를 찾게 되었고, 우리는 아이오닉을 기반으로 진행하게 되었다. 하지만 아이오닉은 자체 라우터를 제공하였고 우리는 그걸 사용하지 못했다. 이유는 아이오닉 자체 라우터는 url 방식이 아니기 때문이다. angular2 라우터를 붙이게 되었고 리덕스를 포함하여 프로젝트를 설계하고 진행하게 되었다. 하지만 트레포트와 인연이 여기까지였다. 나의 의지와 상관 없이 회사에서의 일방적인 통보.. 팀원들과 헤어진다는게 너무 아쉬웠고 팀원들도 같이 화를 내주었다.(2016년 말에 같이 한잔을 했다능..그리고 그 팀원들중에서도 회사를 나온 사람이 좀 있더라…)</p><blockquote><p>내가 만약 40대 50대 아이가 있는데 회사에서 갑자기 퇴사 통보를 한다고 하면.. 얼마나 당황하고 힘들까 라는 생각이 많이 들었다. 회사의 의존된 내가 되지 말고 회사와 관계 없이 나의 가치를 더 올려야겠다.</p></blockquote><h5 id="o2palm"><a href="#o2palm" class="headerlink" title="o2palm"></a>o2palm</h5><p>트레포트를 들어가기전에 스카웃 제의를 받았던 곳이다. 트레포트를 뒤로 두고 입사하게 되었다. 여기는 아에 첫 스타트 업으로 아직 캐쉬카우가 없는 곳이여서 엄청 고민을 했던 곳이였다. 여기 회사는 되게 자유도가 높은 회사이다. 출퇴근 시간이 정해져 있지 않으며, 자택근무를 원하면 언제든 자택근무도 가능하다. 그리고 1년이 지나지 않아도 휴가를 묻지 않고 마음대로 쓸수 있는 곳이다. 원하면 굳이 한국에서 일 안해도 된다고 한다.. 역시 자유에는 그만큼의 책임이 있다. 오투팜은 철저한 성과위주이다. 성과가 없으면 연봉이 감봉된다. 역시나 성과가 좋으면 연봉이 상승되는 구조로 되어 있다. 아직 체계를 잡아가는 중이지만 많이 잡혀가고 있다. 모두다가 지라를 사용하고 있고(개발 뿐만 아니라 모든 직원 대표님까지), 슬랙을 이용하며, 리모트 환경을 잡아가고 있다. 현재 nodeJs와 angular2 그리고 아이오닉으로 개발을 진행하고 있다. 내가 항상 해왔던 것들.. 열심히 해야지..<br>다만 개발팀에서 가장 아쉬운건 신입 2명이다. 올해에는 솔찍히 실망이 컸다. 트레포트의 신입들과 비교가 많이 된다. 내년에는 좀더 잘할꺼라 생각을 하고 다시한번 기대를 해본다.</p><h2 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h2><p>2016년도는 기존 angular1에서 angular2로 바꾸기 시작했고 실제 프로젝트에서도 사용하기 시작했다. 그리고 스터디도 가장 많이 하게 되는 년도이기도 하다. 많은 선배님들이 도와주었고 특히 유자소프트에 합류하게 된것은 너무나도 좋은 기회였고 많은 것들을 배우고 있다.<br>프론트엔드 개발자로써 좀더 나아가기 위해서 어떻게 해야될까 라는 생각을 다시 한번 하게 되었다. javascript에 대해 공부를 좀더 하게 되었고, 오픈소스도 만들게 되었고 그리고 첫 오픈소스 첫 이슈도 등록 되었다.(아직 이슈 처리를 못했다. 얼렁해야지) 많은 글은 등록하지 못했지만 블로그도 시작하게 되었다. </p><p><img src="http://i64.tinypic.com/2ljrvo9.png" alt></p><h2 id="마지막으로"><a href="#마지막으로" class="headerlink" title="마지막으로.."></a>마지막으로..</h2><p>2016년도는 많은 일들이 있었다. 가장 힘든일은 커뮤니케이션에 대한 것이었다. 모든걸 솔찍하게 애기하는건 정말 좋지 않구나 라는 생각도 하게 되었고 말을 많이 안하는게 좀더 좋은 커뮤니케이션인가 라는 생각도 하게 되었다. 솔찍히 아직도 그건 나에게 하나의 숙제로 남아있다. 2017년에도 아마 이건 나의 고민이지 않을까 싶다. 그리고 2016년도에 나를 많이 도와주신 분들이 있는데 너무너무 감사하다고 전달하고 싶다. 특히 자존감에 대해 한번더 생각하게 해준 피터, 항상 내 옆에서 인생의 선배로 그리고 개발자의 방향으로 도움을 주는 동재형님, 나에게 항상 힘이 되는 자성이, 새로운 시각을 가지게 해준 마이클, 항상 개발자의 모습을 보여주고 조언을 해주는 성균형님 너무너무 감사하다.<br>그리고 항상 내 옆에서 응원해주고 힘이 되어 준 우리 와이프 너무 사랑한다. </p><blockquote><p>항상 조금씩 0.000001미리라도 나아가야겠다. 자신감보다 자존감을 키우자.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;블로그를 운영 아닌 운영을 하면서 올해부터는 새롭게 회고를 해볼까 한다.&lt;br&gt;막상 회고를 한다고 하니 어떻게 글을 시작해야될지 머리속이 정리가 안된다. 또한 좋지 못하는 기억력을 다시한번 실감하게 되기도 하다.&lt;br&gt;시작을 어떻게 할까 고민을 
      
    
    </summary>
    
    
      <category term="회고" scheme="https://mayajuni.github.io/categories/%ED%9A%8C%EA%B3%A0/"/>
    
    
      <category term="회고" scheme="https://mayajuni.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
      <category term="2016" scheme="https://mayajuni.github.io/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>es2015 요약</title>
    <link href="https://mayajuni.github.io/2016/12/05/es2015/"/>
    <id>https://mayajuni.github.io/2016/12/05/es2015/</id>
    <published>2016-12-05T05:59:02.000Z</published>
    <updated>2020-05-28T23:36:25.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h1><p>  ES2015는 Javascript의 버전이다.<br> Ecma라는 단체에서 기존의 결점을 보완한 표준 자바스크립트 버전을 매년 발표한다.<br> ES는 EcamaScript의 줄임말이다.</p><h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><ul><li>블록 스코프 변수(block scoped variable)이다.</li><li>var가 함수 스코프 변수 이라는 점에서 대비된다.</li><li>블록 단위안에서도 hoisting 되지 않는다.</li><li>같은 스코프에서 재선언이 불가능하다.</li></ul><p>ex:</p><ol><li><p>블록 스코프 변수 / 함수 스코프 변수 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">'b'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a =&gt; '</span>, a); <span class="comment">// a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b =&gt; '</span>, b); <span class="comment">// b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a =&gt; '</span>, a); <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b =&gt; '</span>, b); <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>hoisting 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a =&gt; '</span>, a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b =&gt; '</span>, b); <span class="comment">// b is not defined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>같은 스코프에서 재선언 불가능 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;  <span class="comment">// a = 'a'</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'aa'</span>; <span class="comment">// a = 'aa'</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'b'</span>;  <span class="comment">// b = 'b'</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'bb'</span>; <span class="comment">// Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><ul><li>읽기 전용 상수</li><li>객체를 할당하면 참조값이 상수에 할당되므로 객체의 프로퍼티는 변경 가능</li><li>const 또한 block scoping을 따르며 hoisting 되지 않는다.</li></ul><p>ex:</p><ol><li><p>읽기 전용 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span>; <span class="comment">// a = 'a'</span></span><br><span class="line">a = <span class="string">'b'</span>        <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p>프로퍼티 변경 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.name =&gt; '</span>, a.name); <span class="comment">// a</span></span><br><span class="line">a.name = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.name =&gt; '</span>, a.name); <span class="comment">// b</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Set-Collection"><a href="#Set-Collection" class="headerlink" title="Set - Collection"></a>Set - Collection</h1><ul><li>Set은 유일한 값들로 구성된 Collection</li><li>add한 순서대로 원소를 가지고 있다.</li><li>중복된 값은 자동 삭제된다.</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">a.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">1</span>); <span class="comment">// Set &#123;1, 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a size: '</span>, a.size); <span class="comment">// 2</span></span><br><span class="line">a.delete(<span class="number">2</span>); <span class="comment">// Set &#123;1&#125;</span></span><br><span class="line">a.forEach(<span class="function"><span class="params">f</span> =&gt;</span> <span class="built_in">console</span>.log(f)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h1 id="WeakSet-Collection"><a href="#WeakSet-Collection" class="headerlink" title="WeakSet - Collection"></a>WeakSet - Collection</h1><ul><li>weakly하게 값을 참조한다는 뜻인데 WeakSet이 갖는 객체의 참조값이 다른곳에서 참조되지 않으면 객체는 garbage collect 대상</li><li>객체 참조값만 가진다.</li><li>iterable 객체가 아니다.</li><li>.has(), .get(), .set(), .delete()만 지원</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> value = &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125;;</span><br><span class="line">ws.add(value).add(&#123;<span class="attr">b</span>: <span class="string">'moon'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ws); <span class="comment">// WeakSet &#123;Object &#123;b: "moon"&#125;, Object &#123;a: "a"&#125;&#125;</span></span><br><span class="line"><span class="comment">/* after the garbage Collection has run */</span></span><br><span class="line"><span class="built_in">console</span>.log(ws); <span class="comment">// WeakSet &#123;Object &#123;a: "a"&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Map-Collection"><a href="#Map-Collection" class="headerlink" title="Map - Collection"></a>Map - Collection</h1><ul><li>key-value로 이루어진 Collection</li><li>iterable 객체</li><li>삽입한 순서대로 원소를 가진다.</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line">map.set(obj, <span class="number">2</span>).set(<span class="number">1</span>, <span class="number">1</span>).set(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map has 1: '</span>, map.has(<span class="number">1</span>)); <span class="comment">// map has 1:  true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value of 1: '</span>, map.get(<span class="number">1</span>)); <span class="comment">// value of 1: 2</span></span><br><span class="line">map.delete(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map has 1: '</span>, map.has(<span class="number">1</span>)); <span class="comment">// map has 1: false</span></span><br></pre></td></tr></table></figure><h1 id="WeakMap-Collection"><a href="#WeakMap-Collection" class="headerlink" title="WeakMap - Collection"></a>WeakMap - Collection</h1><ul><li>WeakSet 과 비슷한 개념으WeakMap 의 key 가 약하게 참조된다.</li><li>key는 객체참조 값만을가진다.</li><li>iterable 객체가 아니다.</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125;;</span><br><span class="line">ws.set(obj, <span class="number">1</span>).set(&#123;<span class="attr">b</span>: <span class="number">2</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ws); <span class="comment">// WeakMap &#123;Object &#123;a: "a"&#125; =&gt; 1, Object &#123;b: 2&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="comment">/* after the garbage Collection has run */</span></span><br><span class="line"><span class="built_in">console</span>.log(ws); <span class="comment">// WeakMap &#123;Object &#123;a: "a"&#125; =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure><h1 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h1><ul><li>보다 간결한 구문을 지닌 익명함수이다.</li><li>자기 고유의 this 를 갖지 않고, 외부 스코프의 this 를 그대로 가진다 (lexical<br>binding)</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">/* json을 리턴할 때에는 괄호를 넣어준다. */</span></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><ul><li>기존모델에 단지 새롭게 추가된 구문일 뿐,전혀 새로운 객체지향 모델이 아니다.</li><li>생성자나 상속의 좀 더 간단하고 명확한 구문이 제공된다.</li><li>생성자는 constructor 로 표현된다.</li><li>클래스 바디는 중괄호 안에 두고 여기에 메소드를 function 키워드 없이 정의한다.</li><li>메소드는 prototype 프로퍼티에 추가된다.</li><li>class는 프로퍼티와 메소드로 이루어져 있다.</li><li>class 는 extends 구문으로 다른 class 를 상속한다.</li><li>자식 클래스에 constructor 가 없으면 부모의 그것이 자동으로 호출된다.</li><li>생성자에서 super 키워드를 통해 상속 계층을 구현한다. this 보다 먼저 사용하지 않으면 예외가 발생한다.</li><li>static 키워드를 통해 정적 메소드를 만들 수 있다. 이 메소드는 클래스 prototype 프로퍼티가 아닌 클래스 자체 메소드<br>다. (유틀리티 함수 작성에 쓰인다.)</li></ul><p>ex:</p><ol><li><p>일반 예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> distance(a, b) &#123;</span><br><span class="line">        <span class="keyword">const</span> dx = a.x - b.x;</span><br><span class="line">        <span class="keyword">const</span> dy = a.y - b.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2)); <span class="comment">// 7.0710678118654755</span></span><br></pre></td></tr></table></figure></li><li><p>상속</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        <span class="keyword">super</span>.speak();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' roars.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lion = <span class="keyword">new</span> Lion(<span class="string">'happy'</span>);</span><br><span class="line">lion.speak();</span><br></pre></td></tr></table></figure></li></ol><h1 id="Template-string"><a href="#Template-string" class="headerlink" title="Template string"></a>Template string</h1><ul><li>백틱(Backtick)을 이용해 문자열을 만드는 새로운 방법</li><li>코드의 가독성을 높여준다.</li><li>${} 표현식을 사용하여 변수, 함수, 연산식 등을 표현 할 수 있다.</li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'dowon'</span>;</span><br><span class="line"><span class="keyword">const</span> myStr = <span class="string">`Hi <span class="subst">$&#123;name&#125;</span>. Have a great day!`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myStr); <span class="comment">// Hi dowon. Have a great day!</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"string text line 1\n"</span>+</span><br><span class="line"><span class="string">"string text line 2"</span>);</span><br><span class="line"><span class="comment">/* "string text line 1</span></span><br><span class="line"><span class="comment"> string text line 2" */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">/* "string text line 1</span></span><br><span class="line"><span class="comment"> string text line 2" */</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">$&#123;a + b&#125;</span> and not <span class="subst">$&#123;<span class="number">2</span> * a + b&#125;</span>.`</span>); <span class="comment">// Fifteen is 15 and not 20.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a: =&gt; <span class="subst">$&#123;a()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h1 id="for-of-구문"><a href="#for-of-구문" class="headerlink" title="for~of 구문"></a>for~of 구문</h1><ul><li>for~in 문은 객체의 열거가능한 모든 속성에 대해 반복했다면, for ~ of 문은 컬렉션의 요소를 반복.</li><li>forEach(), for in 구문과 달리, break, continue, 그리고 return 구문과 함께 사용할 수 있습니다.</li><li>for~of 루프 구문은 data를 순회하기 위한 구문</li><li>배열 뿐만 아니라 Collection 객체, DOM NodeList 등등 을 다를수 있다.</li></ul><p>ex)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> chr <span class="keyword">of</span> <span class="string">"12"</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"a"</span>, <span class="number">1</span>], [<span class="string">"b"</span>, <span class="number">2</span>], [<span class="string">"c"</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [a, 1]</span></span><br><span class="line"><span class="comment">// [b, 2]</span></span><br><span class="line"><span class="comment">// [c, 3]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><ul><li>Iterator 는 새로운 문법이나 built-in 이 아니라 프로토콜(약속)이다.</li><li>간단한 약속만 지키면 누구나 만들수 있다.</li><li>Set Map Array 등이 Iterator 객체이다.</li><li>Symbol.iterator 를 Key 로 갖는 속성이 반드시 존재해야 한다.</li><li>다음 규칙에 따라 next() 메서드를 구현한 객체를 iterator 라고 한다:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">아래의 두 속성을 가지는 객체를 리턴하며 인자가 없는 함수:</span><br><span class="line">1. <span class="keyword">done</span> (boolean)</span><br><span class="line">    - iterator 가 순회를 모두 마쳤을 경우 <span class="literal">true</span></span><br><span class="line">    - iterator 가 순회할 다음 value 가 존재할 경우 <span class="literal">false</span></span><br><span class="line">2. value - iterator 에 의해 리턴될 값. <span class="keyword">done</span> 이 <span class="literal">true</span> 일 경우 생략 가능</span><br></pre></td></tr></table></figure></li></ul><p>ex:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      i: <span class="number">0</span>,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="keyword">this</span>.i++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="Rest-Parameter-와-Default-Parameter"><a href="#Rest-Parameter-와-Default-Parameter" class="headerlink" title="Rest Parameter 와 Default Parameter"></a>Rest Parameter 와 Default Parameter</h1><p>이건 코드로 확인하는게 가장 편하다.</p><ol><li><p>rest parameter</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용법은 아래와 같다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ex</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> arg) <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line">restParam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// es2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam2</span>(<span class="params">first, ...arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first); <span class="comment">// 시작</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> arg) <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">restParam(<span class="string">'시작'</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>Default Parameter</p><ul><li>parameter 값이 없을 시 Default로 값을 넣어준다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultParam</span>(<span class="params">a = <span class="string">'test'</span>, b = <span class="string">'done'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">defaultParam();</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;a,b&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> aCopy = [...a];</span><br><span class="line"><span class="built_in">console</span>.log(aCopy);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES2015&quot;&gt;&lt;a href=&quot;#ES2015&quot; class=&quot;headerlink&quot; title=&quot;ES2015&quot;&gt;&lt;/a&gt;ES2015&lt;/h1&gt;&lt;p&gt;  ES2015는 Javascript의 버전이다.&lt;br&gt; Ecma라는 단체에서 기존의 결점을 보완
      
    
    </summary>
    
    
      <category term="es2015" scheme="https://mayajuni.github.io/categories/es2015/"/>
    
    
      <category term="es2015" scheme="https://mayajuni.github.io/tags/es2015/"/>
    
  </entry>
  
  <entry>
    <title>angular2 실무 프로젝트 회고</title>
    <link href="https://mayajuni.github.io/2016/11/30/angular2-%EC%8B%A4%EB%AC%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0/"/>
    <id>https://mayajuni.github.io/2016/11/30/angular2-실무-프로젝트-회고/</id>
    <published>2016-11-30T12:04:00.000Z</published>
    <updated>2020-05-28T23:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<p>이것은 내가 실무로 프로젝트 리더이였을 때 느꼈던 회고를 기록으로 남긴다.</p><h3 id="대화형-커머스-총-6명"><a href="#대화형-커머스-총-6명" class="headerlink" title="대화형 커머스 - 총 6명"></a>대화형 커머스 - 총 6명</h3><p>Angular2 로 하는 첫 실무  프로젝트이며, 이 프로젝트는 angular2-seed 를 사용하여   진행하였습니다.</p><ul><li>생각외로 typescript 의 진입장벽은 높지 않았고 팀원(신입도)들이 잘 받아드리고 편하게 사용했다.</li><li>rxJs, redux 에 대해 팀원들을 이해시키기까지 어려웠다.(결국 이해한 팀원만 해당 기술 개발을 하고 남어지 팀원은 사용법만 익히게 하였다. 이와 같이 하니 어려움 없이 프로젝트 진행이 가능했다)</li><li>Rc4 으로 시작해서 정식  버전까지 마이그레이션을  했었는데 가장 힘들었을 때가   ngModule 나올 때였다.(Rc5)</li><li>ngModule 을 잘이해하고  설계를 잘해고 개발하면 아주 좋다.(이해하기 편할려면   angular1 의 모듈을 생각하면 될 듯하다.)</li><li>개발하면서 redux 를 사용하였지만 이게 꼭 필요한가에 대해서는    아직도 의문점이다.(있으면 편하긴하다)</li><li>JIT 컴파일보다 AOT 컴파일이 확실히 체감을 느낄  정도로 빠르다. 무조건   필수다.</li><li>Tpyescript 의 타입과 인터페이스는 정말 개발자가 놓치고 있는 부분을 잡아주며, 오류도 적게 내면서 개발속도 즉 생산성도 높혀준다.(typescript 는 정말 좋다)</li><li>Control flow 기반의 코딩이 너무 익숙하다 보니 Data flow 기반의 코딩이 쉽지 않다.(우린 둘다 잘해야된다.)</li><li>rxJs 를 잘 알고 이해하면 angular2 의 코드의 질이   좋아진다.</li><li>zoneJs 도 공부하면 좀더 품질의 코드가 나오지만 자료가 많지    않다.</li></ul><h3 id="일정표-총-3명"><a href="#일정표-총-3명" class="headerlink" title="일정표 - 총 3명"></a>일정표 - 총 3명</h3><p>대화형 커머스가 우선순위에서 밀리면서 시작한 새로운 프로젝트 입니다. 일정이 길지 않아서 ionic2 를 검토하고 잘 맞는다면 그것을 통해 진행을 하자고 했습니다. 확실히 ionic2 는 하이브리드 앱에 적합하였지만 모바일웹으로 사용하기에도 무리가 없었습니다. 그에 맞혀  바로 ionic2 를 가지고 요구  사항을 분석하고 설계하여 첫 번째 angular2 프로젝트의 회고를 토대로 개발을 진행하였고 현재도 진행하고 있습니다.</p><ul><li>Ionic2 에는 라우터가 포함되어 있지 않다.(하지만 angular2 기반이기 때문에 포함 시킬 수 있다.)</li><li>Router 를 썼을씨 html5 base url 을 설정해도 #가 붙는다.(ex.  domail.com/#/login)</li><li>Angular2-seed 보다 설정이 간편하다.(설치만 하고 따로 셋팅을 하지 않아도 된다.)</li><li>Ionic2 serve 는 많이 무겁다(메모리 릭이 잘난다)</li><li>지원하는 component 가 많다.</li><li>Service worker 를 사용한다.(주석 처리되어 있어서 주석만 풀면된다. 지원하지 않는 브라우저는 그냥 패스된다).</li></ul><h3 id="코드리뷰-총-6명"><a href="#코드리뷰-총-6명" class="headerlink" title="코드리뷰 - 총 6명"></a>코드리뷰 - 총 6명</h3><ul><li>서로의 실력 향상에 가장  좋은  방법이다.</li><li>리뷰를 진행하는 사람의 역할이 크다.(리뷰를 하는 사람만 말하는 코드리뷰는  효과가    반감된다.)</li><li>신입들은 꼭 1 질문씩 하는 것으로 진행하였다.(가만히  있는 것은 알고 있다고  생각하여    물어보았다)</li><li>꼭 tsLint 나 jsLint 를 사용하여 코드리뷰 때 컨벤션에 대한 애기가    안나오게  해야된다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이것은 내가 실무로 프로젝트 리더이였을 때 느꼈던 회고를 기록으로 남긴다.&lt;/p&gt;
&lt;h3 id=&quot;대화형-커머스-총-6명&quot;&gt;&lt;a href=&quot;#대화형-커머스-총-6명&quot; class=&quot;headerlink&quot; title=&quot;대화형 커머스 - 총 6명&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="회고" scheme="https://mayajuni.github.io/categories/%ED%9A%8C%EA%B3%A0/"/>
    
    
      <category term="회고" scheme="https://mayajuni.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>nodeJs mysql (async/await를 이용한 mySql 모듈 만들기)</title>
    <link href="https://mayajuni.github.io/2016/07/12/typescript-nodejs-mysql/"/>
    <id>https://mayajuni.github.io/2016/07/12/typescript-nodejs-mysql/</id>
    <published>2016-07-11T23:53:11.000Z</published>
    <updated>2020-05-28T23:36:25.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="node.js-with-mysql.png" alt><br>nodeJs를 이용하여 mysql 혹은 mariaDB 등 RDB를 사용하는 경우가 많다. es7에 제안된 async/await를 사용하여 mysql 모듈을 만들어 볼까 한다.(모듈이라고 하지만 그저 wrapping 한거다.)</p><h2 id="기존-사용-했던-mysql-코드"><a href="#기존-사용-했던-mysql-코드" class="headerlink" title="기존 사용 했던 mysql 코드"></a>기존 사용 했던 mysql 코드</h2><p>처음 mysql을 썼었을때 pool을 이용하여, 매번 connection을 맺고 끊어주고, 또 트랜젝션을 맺고 롤백과 commit을 해주는 코드를 썼다.</p><p>아마 대부분이 아래와 같을 것이다.:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> DBpool  = mysql.createPool(&#123;</span><br><span class="line">  connectionLimit : <span class="number">10</span>,</span><br><span class="line">  host            : <span class="string">'example.org'</span>,</span><br><span class="line">  user            : <span class="string">'bob'</span>,</span><br><span class="line">  password        : <span class="string">'secret'</span>,</span><br><span class="line">  database        : <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = id =&gt; &#123;</span><br><span class="line">    DBpool.getConnection(<span class="function">(<span class="params">err, con</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        con.query(<span class="string">'select * from user where id= ?'</span>, [id], (err, data) =&gt; &#123;</span><br><span class="line">            con.release();</span><br><span class="line">            ...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>트랜젝션을 사용:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pool은 생략</span></span><br><span class="line"><span class="keyword">const</span> insert = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    DBpool.getConnection(<span class="function">(<span class="params">err, con</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        con.beginTransaction(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                con.release();</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            con.query(<span class="string">'select * from user where id = ?'</span>, [id], (err, data) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> con.rollback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        con.release();</span><br><span class="line">                        <span class="keyword">throw</span> err;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                con.query(<span class="string">'insert into user (name) values (?)'</span>, [data[<span class="number">0</span>].name], (err, data) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                        <span class="keyword">return</span> con.rollback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                            con.release();</span><br><span class="line">                            <span class="keyword">throw</span> err;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    con.commit(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            <span class="keyword">return</span> con.rollback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                                con.release();</span><br><span class="line">                                <span class="keyword">throw</span> err;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> con.release();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 되면 매번 db 작업을 할때마다 connection 맺어주고 끊어주는 중복된 코드를 작성해야되며, 트렌젝션을 사용할 때는 콜백헬과 좀더 더 긴 코드를 매번 처리해줘야된다.</p><p>필자는 이렇게 하는 것이 너무나도 마음에 안들었고 매번 중복된 코드를 쓰는게 너무너무 귀찮아서 아래와 같이 만들어서 사용했다.</p><h2 id="1-시작하기"><a href="#1-시작하기" class="headerlink" title="1. 시작하기"></a>1. 시작하기</h2><p>async/await를 사용하기 위해서는 <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>을 사용하거나 <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript</a> 같은 것을 사용해야된다. 필자는 Typescript를 사용하기 때문에 Typescript로 진행 하겠다.</p><p>기본 설정:</p><ol><li>NodeJs 설치</li><li>Typescript 설치</li><li>Typings 설치</li></ol><blockquote><p>자세한 설정은 <a href="https://mayajuni.github.io/2016/06/30/typescript-express_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/">Typescript + ExpressJs 시작하기</a>를 참고하여 진행하면 된다.</p></blockquote><h2 id="2-promise-mysql"><a href="#2-promise-mysql" class="headerlink" title="2. promise-mysql"></a>2. promise-mysql</h2><p>async/await는 전에 <a href="https://mayajuni.github.io/2016/07/04/expressJs-error/">ExpressJs Error</a>에서 설명 했듯이 모든 리턴은 promise로 받아야된다. 그래서 기존 mysql은 callback 기반이기 때문에 사용하지 못하고 npm에 있는 <a href="https://www.npmjs.com/package/promise-mysql" target="_blank" rel="noopener">promise-mysql</a> 모듈을 사용한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save promise-mysql</span><br></pre></td></tr></table></figure><p>promise-mysql모듈은 typings에 없기 때문에 설치를 하지 않고 진행한다.</p><h2 id="3-Module-만들기"><a href="#3-Module-만들기" class="headerlink" title="3. Module 만들기"></a>3. Module 만들기</h2><p>기존에는 모든 함수에 connection 맺고 끊는 혹은 콜백하고 커밋하는 코드를 넣어줬다. 이제 그부분을 분리하여, 모듈로 만들 것이다.</p><h4 id="1-connection"><a href="#1-connection" class="headerlink" title="1) connection"></a>1) connection</h4><p>내가 생각하는 순서는 다음과 같다.:</p><ol><li>function을 받는다.</li><li>받은 function의 paramter들을  <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">“…args”</a>를 사용하여 args에 담는다.</li><li>connection을 맺고 connection 객체를 생성한다.</li><li>받은 function을 connection객체와 함께 기존 paramter(args)를 넘겨주어 실행 시킨다.</li><li>catch를 통해 error가 있을시 connection을 닫아주고 throw error을 해준다.</li><li>error가 없을시에는 connection을 닫아주고 실행된 function을 값을 넘겨준다.</li></ol><p>위와 같이 생각을 했으면, 아마 아래와 같은 코드가 나올 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 기존 import 하는 방식이 아닌 이유는 promise-mysql은</span></span><br><span class="line"><span class="comment"> * 정의 파일(typings)이 없기 때문에 아래와 같이 쓴다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> promiseMysql = <span class="built_in">require</span>(<span class="string">'promise-mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool  = promiseMysql.createPool(&#123;</span><br><span class="line">  connectionLimit : <span class="number">10</span>,</span><br><span class="line">  host: <span class="string">'example.org'</span>,</span><br><span class="line">  user: <span class="string">'bob'</span>,</span><br><span class="line">  password: <span class="string">'secret'</span>,</span><br><span class="line">  database: <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* DB 커넥션을 한다. */</span></span><br><span class="line">    <span class="keyword">let</span> con: any = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">    <span class="comment">/* 로직에 con과 args(넘겨받은 paramter)를 넘겨준다. */</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fn(con, ...args).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 에러시 con을 닫아준다. */</span></span><br><span class="line">        con.connection.release();</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* con을 닫아준다. */</span></span><br><span class="line">    con.connection.release();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-트렌젝션-모듈"><a href="#2-트렌젝션-모듈" class="headerlink" title="2) 트렌젝션 모듈"></a>2) 트렌젝션 모듈</h4><p>트렌젝션 모듈도 위의 connection모듈과 크게 다르지 않을것이다. 그저 롤백과 커밋이 들어간것이다.</p><ol><li>function을 받는다.</li><li>받은 function의 paramter들을  <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">“…args”</a>를 사용하여 args에 담는다.</li><li>connection을 맺고 connection 객체를 생성한다.</li><li>트렌젝션을 시작하는 코드를 넣는다.</li><li>받은 function을 connection객체와 함께 기존 paramter(args)를 넘겨주어 실행 시킨다.</li><li>catch를 통해 error가 있을시 rollback과 connection을 닫아주고 throw error을 해준다.</li><li>error가 없을시에는 commit과 connection을 닫아주고 실행된 function을 값을 넘겨준다.</li></ol><p>위와 같이 생각을 했으면, 아마 아래와 같은 코드가 나올 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pool 생략</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> transaction = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* DB 커넥션을 한다. */</span></span><br><span class="line">    <span class="keyword">const</span> con: any = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">    <span class="comment">/* 트렌젝션 시작 */</span></span><br><span class="line">    <span class="keyword">await</span> con.connection.beginTransaction();</span><br><span class="line">    <span class="comment">/* 비지니스 로직에 con을 넘겨준다. */</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fn(con, ...args).catch(<span class="keyword">async</span> (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* rollback을 진행한다. */</span></span><br><span class="line">         <span class="keyword">await</span> con.rollback();</span><br><span class="line">        <span class="comment">/* 에러시 con을 닫아준다. */</span></span><br><span class="line">        con.connection.release();</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* commit을 해준다. */</span></span><br><span class="line">    <span class="keyword">await</span> con.commit();</span><br><span class="line">    <span class="comment">/* con을 닫아준다. */</span></span><br><span class="line">    con.connection.release();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 만든 모듈을 하나로 합치고 mysql모듈이라고 명칭하면 아래와 같다.</p><figure class="highlight javascript"><figcaption><span>mysql.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 기존 import 하는 방식이 아닌 이유는 promise-mysql은</span></span><br><span class="line"><span class="comment"> * 정의 파일(typings)이 없기 때문에 아래와 같이 쓴다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> promiseMysql = <span class="built_in">require</span>(<span class="string">'promise-mysql'</span>);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span>;</span><br><span class="line"></span><br><span class="line">dotenv.config(&#123;</span><br><span class="line">    silent: <span class="literal">true</span>,</span><br><span class="line">    path: <span class="string">'.env'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = promiseMysql.createPool(&#123;</span><br><span class="line">    connectionLimit : <span class="number">10</span>,</span><br><span class="line">    host: process.env.MYSQL_HOST,</span><br><span class="line">    user: process.env.MYSQL_USER,</span><br><span class="line">    password: process.env.MYSQL_PASSWORD,</span><br><span class="line">    database: process.env.MYSQL_DB</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">module</span> mysql &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* DB 커넥션을 한다. */</span></span><br><span class="line">        <span class="keyword">const</span> con: any = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">        <span class="comment">/* 로직에 con과 args(넘겨받은 paramter)를 넘겨준다. */</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> fn(con, ...args).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/* 에러시 con을 닫아준다. */</span></span><br><span class="line">            con.connection.release();</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/* con을 닫아준다. */</span></span><br><span class="line">        con.connection.release();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">const</span> transaction = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* DB 커넥션을 한다. */</span></span><br><span class="line">        <span class="keyword">const</span> con: any = <span class="keyword">await</span> pool.getConnection();</span><br><span class="line">        <span class="comment">/* 트렌젝션 시작 */</span></span><br><span class="line">        <span class="keyword">await</span> con.connection.beginTransaction();</span><br><span class="line">        <span class="comment">/* 비지니스 로직에 con을 넘겨준다. */</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> fn(con, ...args).catch(<span class="keyword">async</span> (error) =&gt; &#123;</span><br><span class="line">            <span class="comment">/* rollback을 진행한다. */</span></span><br><span class="line">             <span class="keyword">await</span> con.rollback();</span><br><span class="line">            <span class="comment">/* 에러시 con을 닫아준다. */</span></span><br><span class="line">            con.connection.release();</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/* commit을 해준다. */</span></span><br><span class="line">        <span class="keyword">await</span> con.commit();</span><br><span class="line">        <span class="comment">/* con을 닫아준다. */</span></span><br><span class="line">        con.connection.release();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 mysql 모듈이 완성이다.</p><h2 id="4-사용법"><a href="#4-사용법" class="headerlink" title="4. 사용법"></a>4. 사용법</h2><p>일반 connection 사용:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 위에 만든 mysql 모듈이다. */</span></span><br><span class="line"><span class="keyword">import</span> &#123;mysql&#125; <span class="keyword">from</span> <span class="string">"mysql"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = mysql.connect((con: any, id: string) =&gt; con.query('select * from user', [id]));</span><br></pre></td></tr></table></figure><p>너무 간단하게 한줄로 끝내버렸다. 물론 단순 select한 값을 리턴했기 때문에 위와 같이 한줄로 나올수 있는 것이다. 만약 다른 비지니스 로직이 있다고 하면 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 위에 만든 mysql 모듈이다. */</span></span><br><span class="line"><span class="keyword">import</span> &#123;mysql&#125; <span class="keyword">from</span> <span class="string">"mysql"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = mysql.connect(async (con: any, id: string) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> con.query(<span class="string">'select * from user'</span>, [id]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...비지니스로직...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>굳이 동기로 할 필요 없을시에는 async를 빼도 된다.</p><p>트랜젝션을 사용:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 위에 만든 mysql 모듈이다. */</span></span><br><span class="line"><span class="keyword">import</span> &#123;mysql&#125; <span class="keyword">from</span> <span class="string">"mysql"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insert = mysql.transaction(<span class="keyword">async</span> (con: any, <span class="attr">id</span>: string) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> con.query(<span class="string">'select * from user where id = ?'</span>, [id]);</span><br><span class="line">    <span class="keyword">await</span> con.query(<span class="string">'insert into user (name) values (?)'</span>, [user[<span class="number">0</span>].name]);</span><br><span class="line">    <span class="comment">/* 리턴할 값이 없을시 그냥 return만 써도 된다. */</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>트랜젝션을 사용하는 코드는 더욱더 짧아진 코드량을 볼 수 있다.</p><blockquote><p>이 모듈에 대한 예제를 <a href="https://github.com/mayajuni/async-await-mysql" target="_blank" rel="noopener">github</a>에 올렸다. 한번 보면 좀더 이해하기 편할 것이다. 도움이 되었다면 위의 별도 한번 눌러 주는 센스!</p></blockquote><p><code>반말로 블로그를 작성하였는데 이해해주시기 바랍니다. 문의 및 수정 사항은 댓글이나 mayajuni10@gmail.com으로 이메일 보내주시기 바랍니다.</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;node.js-with-mysql.png&quot; alt&gt;&lt;br&gt;nodeJs를 이용하여 mysql 혹은 mariaDB 등 RDB를 사용하는 경우가 많다. es7에 제안된 async/await를 사용하여 mysql 모듈을 만들어 볼까 한
      
    
    </summary>
    
    
      <category term="Typescript" scheme="https://mayajuni.github.io/categories/Typescript/"/>
    
      <category term="nodeJs" scheme="https://mayajuni.github.io/categories/Typescript/nodeJs/"/>
    
    
      <category term="expressjs" scheme="https://mayajuni.github.io/tags/expressjs/"/>
    
      <category term="typescript" scheme="https://mayajuni.github.io/tags/typescript/"/>
    
      <category term="nodejs" scheme="https://mayajuni.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ExpressJs Error</title>
    <link href="https://mayajuni.github.io/2016/07/04/expressJs-error/"/>
    <id>https://mayajuni.github.io/2016/07/04/expressJs-error/</id>
    <published>2016-07-04T00:25:35.000Z</published>
    <updated>2020-05-28T23:36:25.137Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스트에서는 서버 구동에 대해서 포스팅했다. 이번에는 Error 처리에 대해 포스팅 하겠다.</p><h2 id="기본적인-에러처리"><a href="#기본적인-에러처리" class="headerlink" title="기본적인 에러처리"></a>기본적인 에러처리</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    throw new Error(<span class="string">'에러 발생'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>위와 같이 처리를 하면 큰 문제가 생긴다. 아래와 같이 callback을 받아 error 처리를 할 시 절대로 에러를 잡지 못한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    callback(error =&gt; &#123;</span><br><span class="line">        throw new Error(<span class="string">'에러 발생'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>그래서 하는 방식이 next를 통한 에러를 전달하는 방식이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    callback(error =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error) <span class="built_in">return</span> next(error);</span><br><span class="line"></span><br><span class="line">        callback2(error =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(error) <span class="built_in">return</span> next(error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이렇게 처리시 2가지의 문제점을 가지고 있다.</p><ul><li>로직 및 모든 부분에 Error 처리를 해줘야 한다.<br> (이거 의외로 되게 유지보수하기 힘들고, 귀찮은 작업이다. 깜빡 한번하면 그냥 죽어버린다.)</li><li>내가 Error 처리를 하지 못하는 부분에서는 Error처리를 할 수 없다.(모듈 안에서 에러가 났던가, 기타 등등)</li></ul><blockquote><p>위와 같은 문제 때문에 필자는 <a href="https://github.com/brianc/node-domain-middleware" target="_blank" rel="noopener">node-domain-middleware</a> 미들웨어를 사용하여 에러처리를 했다.(편하고 좋았다.) 하지만 <a href="http://expressjs.com/ko/advanced/best-practice-performance.html#section-8" target="_blank" rel="noopener">expressJs의 성능우수 사례</a>를 보면 도메인 사용을 권장하지 않고 더이상 사용되지 않는 모듈이라고 되어 있다.</p></blockquote><h2 id="프로미스를-이용한-에러-처리"><a href="#프로미스를-이용한-에러-처리" class="headerlink" title="프로미스를 이용한 에러 처리"></a>프로미스를 이용한 에러 처리</h2><p>es2015에 있는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>를 이용하여 Error 처리 하는 방식이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    callback()</span><br><span class="line">        .<span class="keyword">then</span>(_ =&gt; &#123;</span><br><span class="line">            // 로직1</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="keyword">then</span>(_ =&gt; &#123;</span><br><span class="line">            // 로직2</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(next);</span><br><span class="line">&#125;)</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>위와 같이 하면 catch를 통해 promise로 처리하는 부분의 모든 error를 처리 할 수 있다. 위에 단점으로 적었던 2가지 전부를 해결 할 수 있다. 나의 생각 일 수 있지만 코드도 좀더 간결해 보인다(아닐수도 있다.)<br>하지만 여기서 코드를 좀더 간결하게 해보도록 하겠다. es7 스팩인 async/await를 이용할 것이다.</p><h3 id="async-await-이용한-에러-처리"><a href="#async-await-이용한-에러-처리" class="headerlink" title="async/await 이용한 에러 처리"></a>async/await 이용한 에러 처리</h3><p> async/await가 다소 생소 할 수 있다. 비동기 코드를 동기화 간편하게 해주는 것이다. es7에 제안된 스팩이며, 자세한 내용은 <a href="https://blogs.msdn.microsoft.com/typescript/2015/11/03/what-about-asyncawait/" target="_blank" rel="noopener">이곳</a>을 보자. 구글 검색해도 많이 나온다.</p><blockquote><p>async/await 사용하기 위해서는 <a href="https://babeljs.io/docs/usage/cli/" target="_blank" rel="noopener">Babel</a> 혹은 <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">typescript</a> 등을 사용해야된다. 필자는 typescript를 사용한다.</p></blockquote><ol><li><p>처음에는 우선 아래와 같이 (req, res, next) 부분을 감싸도록 하겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const wrap = fn =&gt; (...args) =&gt; fn(...args).catch(args[2]);</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">“…args”</a>는 es2015 문법이다. 이렇게 사용하면 args안에 parameter 값들이 순차적으로 들어가게된다.<br>wrap은 함수를 받아서 그 함수를 실행 하고 catch를 통해 error가 발생시 next(error)을 해주는 역활이다. router에서는 기본적으로 paramter를 req, res, next를 주기 때문에 args[2]는 next 이다.</p><p>이걸 풀어서 아래와 같이 할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const wrap = fn =&gt; (req, res, next) =&gt; fn(req, res, next).catch(next);</span><br></pre></td></tr></table></figure></li><li><p>만든 wrap을 아래와 같이 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, wrap(async (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> data = await callback();</span><br><span class="line">    <span class="built_in">let</span> data2 = await 로직1();</span><br><span class="line">    /* 리턴 값이 없음 아래와 같이 써도 된다. */</span><br><span class="line">    await 로직2();</span><br><span class="line">&#125;))</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>코드를 보면 짐작하시겠지만 async/await를 통해 비동기 로직을 동기식으로 간편하게 로직처리 한다.</p></li></ol><blockquote><p>여기에도 유의점이 있다. 이것을 사용하기 위해서는 return promise 이어야된다. 단순 callback에 대한 처리를 할 수 없다. 하지만 많은 모듈 혹은 미들웨어가 promise를 제공(?)하기 때문에 사용하기에는 불편함이 없다.(기존 로직은 async/await로 처리하면되며, mongoose나 mysql 같은경우 이미  promise를 사용 할 수 있어 큰 불편이 없다.)</p></blockquote><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>직접 이렇게 하고 사용을 하면 생산성이 확실히 빨라진다. 코드도 짧아지고 가독성도 좋아 진다. 이렇게 한번 쓰기 시작하면서 모든 노드 프로젝트는 이 방식으로 개발하고 있다. 필자는 이 방식(방법)을 추천한다.</p><h5 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h5><ul><li><a href="https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/" target="_blank" rel="noopener">Asynchronous Error Handling in Express with Promises, Generators and ES7</a></li><li><a href="http://expressjs.com/ko/advanced/best-practice-performance.html" target="_blank" rel="noopener">프로덕션 우수 사례: 성능 및 신뢰성</a></li></ul><p><code>반말로 블로그를 작성하였는데 이해해주시기 바랍니다. 문의 및 수정 사항은 댓글이나 mayajuni10@gmail.com으로 이메일 보내주시기 바랍니다.</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 포스트에서는 서버 구동에 대해서 포스팅했다. 이번에는 Error 처리에 대해 포스팅 하겠다.&lt;/p&gt;
&lt;h2 id=&quot;기본적인-에러처리&quot;&gt;&lt;a href=&quot;#기본적인-에러처리&quot; class=&quot;headerlink&quot; title=&quot;기본적인 에러처리&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="ExpressJs" scheme="https://mayajuni.github.io/categories/ExpressJs/"/>
    
    
      <category term="expressjs" scheme="https://mayajuni.github.io/tags/expressjs/"/>
    
      <category term="router" scheme="https://mayajuni.github.io/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>Typescript + ExpressJs 시작하기</title>
    <link href="https://mayajuni.github.io/2016/06/30/typescript-express/"/>
    <id>https://mayajuni.github.io/2016/06/30/typescript-express/</id>
    <published>2016-06-30T00:07:00.000Z</published>
    <updated>2020-05-28T23:36:25.137Z</updated>
    
    <content type="html"><![CDATA[<p><img src="typescript-express-nodejs.jpg" alt></p><p>최근 <a href="https://angular.io/" target="_blank" rel="noopener">Angular2.0</a> 을 스터디 하면 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript</a>를 알게 되었다. 사용하면서 모든 javascript에 적용을 시키면 정말 편할꺼 같아서 개인적으로 Restful Api 서버를 만들어 보고, 그걸을 토대로 기록을 남긴다.</p><h1 id="시작하기-및-설정"><a href="#시작하기-및-설정" class="headerlink" title="시작하기 및 설정"></a>시작하기 및 설정</h1><p>시작하기 전에 먼저 설치를 해야된다.</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJs</a> 6버젼 이상을 추천한다.(es2015지원이 빵빵하다!)</li><li><a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">Typescript</a></li></ul><p>NodeJs는 해당 홈페이지 들어가서 다운로드를 받고 설치하면 문제 없지 진행 할 수 있다.<br>Typescript 설치는 터미널을 열고 아래와 같이 npm으로 간편하게 설치가 가능하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h2 id="1-프로젝트-설정"><a href="#1-프로젝트-설정" class="headerlink" title="1. 프로젝트 설정"></a>1. 프로젝트 설정</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp</span><br><span class="line"><span class="built_in">cd</span> myapp</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>npm init을 했을시 package.json을 생성시켜주지만 직접 파일로 만들어도 된다.</p><blockquote><p>package.json<br> : 필요한 노드 모듈을 정의하고 프로젝트 설명이 기록되어 있다. 또한 npm 실행 script도 사용할수 있다.</p></blockquote><figure class="highlight javascript"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myapp"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>초기 셋팅을 하면 위와 같이 된다.</p><h2 id="2-expressJs-설치"><a href="#2-expressJs-설치" class="headerlink" title="2. expressJs 설치"></a>2. expressJs 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br></pre></td></tr></table></figure><p>위와 같이 express 설치를 하면 package.json에 아래와 같이 추가가 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"^4.14.0"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-typings"><a href="#3-typings" class="headerlink" title="3. typings"></a>3. typings</h2><blockquote><p>typings<br> : 타입스크립트에서 사용되는 모듈 혹은 라이브러리 등등의 정의가 있는 파일이다.(쉽게 말해 자동완성 기능을 해준다.) 기능과 사용법 자세한 설명은 <a href="https://github.com/typings/typings" target="_blank" rel="noopener">Typings</a>에서 보자</p></blockquote><p>설치와 설정은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typings</span><br><span class="line">typings init</span><br></pre></td></tr></table></figure><p>typings init을 하면 typings.json이 생성된다. 여기에 우리가 설치한 Definition File들이 기록된다.</p><blockquote><p>NodeJs를 통해 사용되는 모듈뿐만 아니라 그 이외의 수많은 Definition이 있기 때문에 검색 후 설치하는 것을 권장한다. typings search [모듈이름] 으로 찾을 수 있으며, typings install로 설치가 가능하다.</p></blockquote><p>typings.json이 만들어졌으면, 우리가 사용한 모듈이랑 노드에 대해 설치를 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typings install env~node --save --global</span><br><span class="line">typings install dt~express --save --global</span><br></pre></td></tr></table></figure><p>위의 문법은 <a href="https://github.com/typings/typings" target="_blank" rel="noopener">Typings</a>에 가면 설명나와 있다.</p><blockquote><p>아마 위에 2개만 설치하고 타입스크립트 컴파일을 하면 에러가 떨어질 것이다. 이유는 express 정의 파일안에 serve-static, express-serve-static-core 파일을 import 하는 부분이 있다. 또 serve-static 안에 mime라는 정의를 임포트 하기 때문에 같이 설치한다.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typings install dt~serve-static --save --global</span><br><span class="line">typings install dt~express-serve-static-core --save --global</span><br><span class="line">typings install dt~mime --save --global</span><br></pre></td></tr></table></figure><p>설치가 완료 되면 typings.json을 보면 아래와 같이 되어 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;myapp&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">  &quot;globalDependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;registry:dt/express#4.0.0+20160317120654&quot;,</span><br><span class="line">    &quot;express-serve-static-core&quot;: &quot;registry:dt/express-serve-static-core#0.0.0+20160625155614&quot;,</span><br><span class="line">    &quot;node&quot;: &quot;registry:env/node#6.0.0+20160622202520&quot;,</span><br><span class="line">    &quot;mime&quot;: &quot;registry:dt/mime#0.0.0+20160316155526&quot;,</span><br><span class="line">    &quot;serve-static&quot;: &quot;registry:dt/serve-static#0.0.0+20160606155157&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 파일을 만들고 위와 같이 작성후 <code>typings install</code>로 한꺼번에 설치가 가능하다.</p><blockquote><p>모든 모듈, 라이브러리 등등에 정의 파일이 존재하지 않는다. 그래서 정의 파일을 사용하지 않아도 오류 없이 사용이 가능하다.<code>const redisStore = require(&quot;connect-redis&quot;);</code> 이와 같이 선언하면 정의 파일 없이도 에러 없이 사용 가능하다.</p></blockquote><h2 id="4-typescript-설정"><a href="#4-typescript-설정" class="headerlink" title="4. typescript 설정"></a>4. typescript 설정</h2><p>typescript를 사용하면 tsconfig.json라는 파일을 만들어서 설정을 진행 할 수 있다. 자세한 설명은 <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">공식홈페이지</a>에서 확인 할 수 있다.</p><figure class="highlight bash"><figcaption><span>tsconfig.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es6"</span>,</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"typings"</span>,</span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 내용으로 파일을 만든다.</p><p>이제 거의 완성이 되었다. 이렇게 되면 아래와 같은 구조가 된다.(하위 폴더는 생략)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">├── typings</span><br><span class="line">├── package.json</span><br><span class="line">├── typings.json</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><h1 id="코딩-시작"><a href="#코딩-시작" class="headerlink" title="코딩 시작"></a>코딩 시작</h1><p>여기까지 오셨으면 설치 및 설정까지 완료된 것이다. 이제부턴 코드를 작성하겠다.<br>es2015를 기반으로 사용할것이며, 기본적으로 es2015를 공부하면 좀더 좋다. 물론 es5로 코딩도 가능하다.<br>post, get, delete, put 메소드를 사용하여 {result : Hello world}를 리턴을 목표로 한다</p><h2 id="1-테스트-코드-만들기"><a href="#1-테스트-코드-만들기" class="headerlink" title="1. 테스트 코드 만들기"></a>1. 테스트 코드 만들기</h2><p>우리가 만든 예제가 잘 돌아가는지 테스트를 하기 위해 mocha를 이용하여 테스트 코드를 만든다. 테스트 코드에 대해서는 설명을 하진 않겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mocha</span><br><span class="line">npm install --save-dev should</span><br><span class="line">npm install --save-dev supertest</span><br><span class="line"></span><br><span class="line">typings install dt~mocha --save --global</span><br><span class="line">typings install dt~should --save --global</span><br></pre></td></tr></table></figure><p>위에 것들을 다 설치하면 바로 test 폴더를 만들고 그안에 app.spec.ts 파일을 만든다.</p><figure class="highlight javascript"><figcaption><span>./test/app.spec.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server: any = request.agent(<span class="string">'http://localhost:3000'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'테스트 시작'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'GET'</span>, done =&gt; server.get(<span class="string">'/'</span>).expect(<span class="number">200</span>).expect(<span class="string">"Content-type"</span>,/json/)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            res.body.should.be.a.Object();</span><br><span class="line">            res.body.should.have.property(<span class="string">'result'</span>);</span><br><span class="line">            res.body.result.should.equal(<span class="string">'Hello World'</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;));</span><br><span class="line">    it(<span class="string">'POST'</span>, done =&gt; server.post(<span class="string">'/'</span>).expect(<span class="number">200</span>).expect(<span class="string">"Content-type"</span>,/json/)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            res.body.should.be.a.Object();</span><br><span class="line">            res.body.should.have.property(<span class="string">'result'</span>);</span><br><span class="line">            res.body.result.should.equal(<span class="string">'Hello World'</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;));</span><br><span class="line">    it(<span class="string">'DELETE'</span>, done =&gt; server.delete(<span class="string">'/'</span>).expect(<span class="number">200</span>).expect(<span class="string">"Content-type"</span>,/json/)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            res.body.should.be.a.Object();</span><br><span class="line">            res.body.should.have.property(<span class="string">'result'</span>);</span><br><span class="line">            res.body.result.should.equal(<span class="string">'Hello World'</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;));</span><br><span class="line">    it(<span class="string">'PUT'</span>, done =&gt; server.put(<span class="string">'/'</span>).expect(<span class="number">200</span>).expect(<span class="string">"Content-type"</span>,/json/)</span><br><span class="line">        .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            res.body.should.be.a.Object();</span><br><span class="line">            res.body.should.have.property(<span class="string">'result'</span>);</span><br><span class="line">            res.body.result.should.equal(<span class="string">'Hello World'</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이제 테스트 코드도 만들었겠다. 슬슬 본격적인 코딩에 들어가겠다.</p><h2 id="2-app-ts"><a href="#2-app-ts" class="headerlink" title="2. app.ts"></a>2. app.ts</h2><p>서버에 대한 설정을 하는 역활을 한다. 이 글에서는 간단하게 router랑 기본 설정말 할것이며, 이후 logging, db(mongo,mysql etc)설정, session(redis, cookie)등의 설정은 다루지 않겠다.</p><p>완성까지는 아니지만 express + typescript + mongodb 를 활용하여 만든 <a href="https://github.com/mayajuni/blog/tree/master/server-node" target="_blank" rel="noopener">github</a>를보면 알 수 있다. 그안에 logging부터 restapi 테스트까지 전부 있다.</p><p>코딩하는 방법은 여러가지가 있겠지만 es2015의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">Class</a>를 사용하겠다.</p><figure class="highlight javascript"><figcaption><span>app.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">"express"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* app에 대한 타입 설정 */</span></span><br><span class="line">    public app: express.Application;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">/* express 설정을 위한 express 선언 */</span></span><br><span class="line">        <span class="keyword">this</span>.app = express();</span><br><span class="line">        <span class="comment">/* 라우터 */</span></span><br><span class="line">        <span class="keyword">this</span>.router();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Not Foud */</span></span><br><span class="line">        <span class="keyword">this</span>.app.use(<span class="function">(<span class="params">req: express.Request, res: express.Response, next: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  Error이라는 정의가 있지만 Error에는 status라는 정의가 없어서 any 설정</span></span><br><span class="line"><span class="comment">             *  (아마 typescript로 개발하다보면 any를 많이 쓰게된다)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">const</span> err: any = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not_found'</span>);</span><br><span class="line">            err.status = <span class="number">404</span>;</span><br><span class="line">            next(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 에러 처리 */</span></span><br><span class="line">        <span class="keyword">this</span>.app.use(<span class="function">(<span class="params">err: any, req: express.Request, res: express.Response</span>) =&gt;</span> &#123;</span><br><span class="line">            err.status  = err.status || <span class="number">500</span>;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">`error on requst <span class="subst">$&#123;req.method&#125;</span> | <span class="subst">$&#123;req.url&#125;</span> | <span class="subst">$&#123;err.status&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.error(err.stack || <span class="string">`<span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">            err.message = err.status  == <span class="number">500</span> ? <span class="string">'Something bad happened.'</span> : err.message;</span><br><span class="line">            res.status(err.status).send(err.message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private router() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 에러 처리를 좀더 쉽게 하기 위해서 한번 감싸준다.</span></span><br><span class="line"><span class="comment">         * es7에 제안된 async await를 사용하여 에러처리시 catch가 되기 편하게 해준 방식이다.</span></span><br><span class="line"><span class="comment">         * http://expressjs.com/ko/advanced/best-practice-performance.html#section-10 을 참고하면 좋다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> wrap = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> fn(req, res, next).catch(next);</span><br><span class="line">        <span class="comment">//get router</span></span><br><span class="line">        <span class="keyword">const</span> router: express.Router = express.Router();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get</span></span><br><span class="line">        router.get(<span class="string">"/"</span>, wrap(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">            res.status(<span class="number">200</span>).json(&#123;<span class="attr">result</span>: <span class="string">"Hello World"</span>&#125;)</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//post</span></span><br><span class="line">        router.post(<span class="string">"/"</span>, wrap(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">            res.status(<span class="number">200</span>).json(&#123;<span class="attr">result</span>: <span class="string">"Hello World"</span>&#125;)</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//put</span></span><br><span class="line">        router.put(<span class="string">"/"</span>,  wrap(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">            res.status(<span class="number">200</span>).json(&#123;<span class="attr">result</span>: <span class="string">"Hello World"</span>&#125;)</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//delete</span></span><br><span class="line">        router.delete(<span class="string">"/"</span>,  wrap(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">            res.status(<span class="number">200</span>).json(&#123;<span class="attr">result</span>: <span class="string">"Hello World"</span>&#125;)</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.app.use(router);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 라우터 부분은 추후 한번 더 블로깅 하겠다. 자세하게 보고 싶으면 <a href="http://expressjs.com/ko/advanced/best-practice-performance.html#section-10" target="_blank" rel="noopener">expressJs 성능 우수 사례의 올바른 예외처리(프로미스 사용)</a>를 참고하면 된다.</p><h2 id="3-server-ts"><a href="#3-server-ts" class="headerlink" title="3. server.ts"></a>3. server.ts</h2><p>app.ts에 설정된 내용을 가지고 서버를 만들고 스타트 하는 역활을 한다. 물론 app.ts에서 해도 되지만 확정성을 고려하여 따로 분리한다.</p> <figure class="highlight javascript"><figcaption><span>server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Server&#125; <span class="keyword">from</span> <span class="string">'./app'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">"express"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 따로 설정하지 않았으면 3000 port를 사용한다. */</span></span><br><span class="line"><span class="keyword">const</span> port: number = process.env.PORT || <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> app: express.Application = <span class="keyword">new</span> Server().app;</span><br><span class="line">app.set(<span class="string">'port'</span>, port);</span><br><span class="line"></span><br><span class="line">app.listen(app.get(<span class="string">'port'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Express server listening on port '</span> + port);</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-server-run"><a href="#4-server-run" class="headerlink" title="4. server run"></a>4. server run</h2><p>타입 스크립트는 한번 컴파일을 하지 않으면 js 파일이 생성되지 않는다 그렇게 때문에 꼭 컴파일을 해야된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --p tsconfig.json</span><br></pre></td></tr></table></figure><p>이렇게 하면 ts파일 이외의 js 파일과 js.map 파일이 생성된다.</p><blockquote><p>ts 파일이 위치한 곳에 생성되기 때문에 안좋아 보일수 있다. gulp나 grunt를 사용하면 해결 할 수 있다.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server</span><br></pre></td></tr></table></figure><p>위와 같이 하면 서버가 구동된다.<br><img src="%EC%84%9C%EB%B2%84%EA%B5%AC%EB%8F%99.PNG" alt></p><p>구동 까지 완료 되었으면, 처음에 만든 테스트를 실행 하여, 제대로 되는지 확인한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mocha</span><br></pre></td></tr></table></figure><p>mocha만 치면 프로젝트의 test폴더 안에 있는 모든 테스트 파일을 구동한다.<br>이제 결과는 아래와 같다.<br><img src="%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B2%B0%EA%B3%BC.PNG" alt></p><p>물론 웹으로 요청 한 것도 볼 수 있다.<br><img src="%EC%9B%B9%EA%B2%B0%EA%B3%BC.PNG" alt></p><p>마지막으로 package.json에 script 추가한다.</p><figure class="highlight bash"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myapp"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"npm run tsc &amp; mocha"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run tsc &amp;&amp; node server"</span>,</span><br><span class="line">    <span class="string">"tsc"</span>: <span class="string">"tsc --p tsconfig.json"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"^4.14.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"mocha"</span>: <span class="string">"^2.5.3"</span>,</span><br><span class="line">    <span class="string">"should"</span>: <span class="string">"^9.0.2"</span>,</span><br><span class="line">    <span class="string">"supertest"</span>: <span class="string">"^1.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아주 기본적인 구동 및 테스트만 했다.<br>언제든 궁금한 사항이나 버그, 오류가 있을 시 <a href="mailto:mayajuni10@gmail.com" target="_blank" rel="noopener">mayajuni10@gmail.com</a>으로 이메일 주시거나 혹은 아래의 댓글로 남겨주시면 수정 및 최대한 아는 범위에서 답변 하겠다.</p><p>테스트로 만든 예제 또한 <a href="https://github.com/mayajuni/myapp" target="_blank" rel="noopener">github</a>에 공개되어 있어 볼수 있다.</p><p><code>반말로 블로그를 작성하였는데 이해해주시기 바랍니다.</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;typescript-express-nodejs.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular2.0&lt;/a&gt; 을 스터디
      
    
    </summary>
    
    
      <category term="Typescript" scheme="https://mayajuni.github.io/categories/Typescript/"/>
    
      <category term="nodeJs" scheme="https://mayajuni.github.io/categories/Typescript/nodeJs/"/>
    
    
      <category term="expressjs" scheme="https://mayajuni.github.io/tags/expressjs/"/>
    
      <category term="typescript" scheme="https://mayajuni.github.io/tags/typescript/"/>
    
      <category term="nodejs" scheme="https://mayajuni.github.io/tags/nodejs/"/>
    
  </entry>
  
</feed>
